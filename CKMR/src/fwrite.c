/*
 * This is from data.table devel version 1.10.5
 * Slightly modified, or heavily, however you wish to rank that.
 * Huge thanks to Matt Dowle for his help and willingness to let me play
 * 
 */

#include "fwriteLookups.h"
#include <errno.h>
#include <unistd.h>    // for access()
#include <fcntl.h>
#include <stdbool.h>   // true and false
#include <stdlib.h>    // abs
#include <string.h>    // strlen, strerror

#ifdef WIN32
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#define WRITE _write
#define CLOSE _close
#else
#define WRITE write
#define CLOSE close
#endif

#define STOP error
#define STRICT_R_HEADERS
#define USE_RINTERNALS

//#include "fwrite.h"
#include <stdint.h>

/* fwrite.h stuff begin */

#include <R.h>
#include <Rinternals.h>
#include <Rdefines.h>

typedef void (*writer_fun_t)(void *, int64_t, char **);

void writeInt32();
void writeFloat64();
void writeString();

void write_chars(const char *source, char **dest);

SEXP fwriteMain(SEXP MAT, SEXP filename_Arg, SEXP sep_Arg,
                SEXP eol_Arg, SEXP dec_Arg, SEXP buffMB_Arg);

/* fwrite.h stuff end */


#define NUM_SF   15
#define SIZE_SF  1000000000000000ULL  // 10^NUM_SF

static char sep;                       // comma in .csv files
static char dec;                       // the '.' in the number 3.1416. In Europe often: 3,1416
static uint8_t wf;                    // From fwriter.c


// Non-agnostic helpers ...
const char *getString(SEXP *col, int64_t row) {   // TODO: inline for use in fwrite.c
  SEXP x = col[row];
  return x==NA_STRING ? NULL : CHAR(x);
}

//from fwriteR.c
writer_fun_t funs[] = {
  &writeInt32,
  &writeFloat64,
};

typedef enum {   // same order as fun[] above
  WF_Int32,
  WF_Float64,
} WFs;

inline void write_chars(const char *x, char **pch)
{
  // similar to C's strcpy but i) doesn't include trailing \0 and ii) moves destination along
  char *ch = *pch;
  while (*x) *ch++=*x++;
  *pch = ch;
}

static inline void reverse(char *upp, char *low)
{
  upp--;
  while (upp>low) {
    char tmp = *upp;
    *upp = *low;
    *low = tmp;
    upp--;
    low++;
  }
}

void writeInt32(int32_t *col, int64_t row, char **pch)
{
  char *ch = *pch;
  int32_t x = col[row];
  if (x<0) { *ch++ = '-'; x=-x; }
  // Avoid log() for speed. Write backwards then reverse when we know how long.
  char *low = ch;
  do { *ch++ = '0'+x%10; x/=10; } while (x>0);
  reverse(ch, low);
  *pch = ch;
}


/*
* Generate fwriteLookup.h which defines sigparts, expsig and exppow that writeNumeric() that follows uses.
* It was run once a long time ago in dev and we don't need to generate it again unless we change it.
* Commented out and left here in the file where its result is used, in case we need it in future.
* Reason: ldexpl may not be available on all platforms and is slower than a direct lookup when it is.
*
void genLookups() {
FILE *f = fopen("/tmp/fwriteLookups.h", "w");
fprintf(f, "//\n                                                               \
// Generated by fwrite.c:genLookups()\n                                        \
//\n                                                                           \
// 3 vectors: sigparts, expsig and exppow\n                                    \
// Includes precision higher than double; leave this compiler on this machine\n\
// to parse the literals at reduced precision.\n                               \
// 2^(-1023:1024) is held more accurately than double provides by storing its\n\
// exponent separately (expsig and exppow)\n                                   \
// We don't want to depend on 'long double' (>64bit) availability to generate\n\
// these at runtime; libraries and hardware vary.\n                            \
// These small lookup tables are used for speed.\n                             \
//\n\n");
fprintf(f, "const double sigparts[53] = {\n0.0,\n");
for (int i=1; i<=52; i++) {
fprintf(f, "%.40Le%s\n",ldexpl(1.0L,-i), i==52?"":",");
}
fprintf(f, "};\n\nconst double expsig[2048] = {\n");
char x[2048][60];
for (int i=0; i<2048; i++) {
sprintf(x[i], "%.40Le", ldexpl(1.0L, i-1023));
fprintf(f, "%.*s%s\n", (int)(strchr(x[i],'e')-x[i]), x[i], (i==2047?"":",") );
}
fprintf(f, "};\n\nconst int exppow[2048] = {\n");
for (int i=0; i<2048; i++) {
fprintf(f, "%d%s", atoi(strchr(x[i],'e')+1), (i==2047?"":",") );
}
fprintf(f, "};\n\n");
fclose(f);
return R_NilValue;
}
*/

void writeFloat64(double *col, int64_t row, char **pch)
{
  // hand-rolled / specialized for speed
  // *pch is safely the output destination with enough space (ensured via calculating maxLineLen up front)
  // technique similar to base R (format.c:formatReal and printutils.c:EncodeReal0)
  // differences/tricks :
  //   i) no buffers. writes straight to the final file buffer passed to write()
  //  ii) no C libary calls such as sprintf() where the fmt string has to be interpretted over and over
  // iii) no need to return variables or flags.  Just writes.
  //  iv) shorter, easier to read and reason with in one self contained place.
  double x = col[row];
  char *ch = *pch;
  
  if (x == 0.0) {
    *ch++ = '0';   // and we're done.  so much easier rather than passing back special cases
  } else {
    if (x < 0.0) { *ch++ = '-'; x = -x; }  // and we're done on sign, already written. no need to pass back sign
    union { double d; uint64_t l; } u;
    u.d = x;
    uint64_t fraction = u.l & 0xFFFFFFFFFFFFF;           // (1<<52)-1;
    uint32_t exponent = (int32_t)((u.l>>52) & 0x7FF);    // [0,2047]
    
    // Now sum the appropriate powers 2^-(1:52) of the fraction
    // Important for accuracy to start with the smallest first; i.e. 2^-52
    // Exact powers of 2 (1.0, 2.0, 4.0, etc) are represented precisely with fraction==0
    // Skip over tailing zeros for exactly representable numbers such 0.5, 0.75
    // Underflow here (0u-1u = all 1s) is on an unsigned type which is ok by C standards
    // sigparts[0] arranged to be 0.0 in genLookups() to enable branch free loop here
    double acc = 0;  // 'long double' not needed
    int i = 52;
    if (fraction) {
      while ((fraction & 0xFF) == 0) { fraction >>= 8; i-=8; }
      while (fraction) {
        acc += sigparts[(((fraction & 1u)^1u)-1u) & i];
        i--;
        fraction >>= 1;
      }
    }
    // 1.0+acc is in range [1.5,2.0) by IEEE754
    // expsig is in range [1.0,10.0) by design of fwriteLookups.h
    // Therefore y in range [1.5,20.0)
    // Avoids (potentially inaccurate and potentially slow) log10/log10l, pow/powl, ldexp/ldexpl
    // By design we can just lookup the power from the tables
    double y = (1.0+acc) * expsig[exponent];  // low magnitude mult
    int exp = exppow[exponent];
    if (y>=9.99999999999999) { y /= 10; exp++; }
    uint64_t l = y * SIZE_SF;  // low magnitude mult 10^NUM_SF
    // l now contains NUM_SF+1 digits as integer where repeated /10 below is accurate
    
    if (l%10 >= 5) l+=10; // use the last digit to round
    l /= 10;
    if (l == 0) {
      if (*(ch-1)=='-') ch--;
      *ch++ = '0';
    } else {
      // Count trailing zeros and therefore s.f. present in l
      int trailZero = 0;
      while (l%10 == 0) { l /= 10; trailZero++; }
      int sf = NUM_SF - trailZero;
      if (sf==0) {sf=1; exp++;}  // e.g. l was 9999999[5-9] rounded to 10000000 which added 1 digit
      
      // l is now an unsigned long that doesn't start or end with 0
      // sf is the number of digits now in l
      // exp is e<exp> were l to be written with the decimal sep after the first digit
      int dr = sf-exp-1; // how many characters to print to the right of the decimal place
      int width=0;       // field width were it written decimal format. Used to decide whether to or not.
      int dl0=0;         // how many 0's to add to the left of the decimal place before starting l
      if (dr<=0) { dl0=-dr; dr=0; width=sf+dl0; }  // 1, 10, 100, 99000
      else {
        if (sf>dr) width=sf+1;                     // 1.234 and 123.4
        else { dl0=1; width=dr+1+dl0; }            // 0.1234, 0.0001234
      }
      // So:  3.1416 => l=31416, sf=5, exp=0     dr=4; dl0=0; width=6
      //      30460  => l=3046, sf=4, exp=4      dr=0; dl0=1; width=5
      //      0.0072 => l=72, sf=2, exp=-3       dr=4; dl0=1; width=6
      if (width <= sf + (sf>1) + 2 + (abs(exp)>99?3:2)) {
        //              ^^^^ to not include 1 char for dec in -7e-04 where sf==1
        //                      ^ 2 for 'e+'/'e-'
        // decimal format ...
        ch += width-1;
        if (dr) {
          while (dr && sf) { *ch--='0'+l%10; l/=10; dr--; sf--; }
          while (dr) { *ch--='0'; dr--; }
          *ch-- = dec;
        }
        while (dl0) { *ch--='0'; dl0--; }
        while (sf) { *ch--='0'+l%10; l/=10; sf--; }
        // ch is now 1 before the first char of the field so position it afterward again, and done
        ch += width+1;
      } else {
        // scientific ...
        ch += sf;  // sf-1 + 1 for dec
        for (int i=sf; i>1; i--) {
          *ch-- = '0' + l%10;
          l /= 10;
        }
        if (sf == 1) ch--; else *ch-- = dec;
        *ch = '0' + l;
        ch += sf + (sf>1);
        *ch++ = 'e';  // lower case e to match base::write.csv
        if (exp < 0) { *ch++ = '-'; exp=-exp; }
        else { *ch++ = '+'; }  // to match base::write.csv
        if (exp < 100) {
          *ch++ = '0' + (exp / 10);
          *ch++ = '0' + (exp % 10);
        } else {
          *ch++ = '0' + (exp / 100);
          *ch++ = '0' + (exp / 10) % 10;
          *ch++ = '0' + (exp % 10);
        }
      }
    }
  }
  *pch = ch;
}


static inline void write_string(const char *x, char **pch)
{
  char *ch = *pch;
  
  write_chars(x, &ch);
  
  *pch = ch;
}

void writeString(void *col, int64_t row, char **pch)
{
  write_string(getString(col, row), pch);
}


static int rowsPerBatch;

static inline void checkBuffer(
    char **buffer,       // this thread's buffer
    size_t *myAlloc,     // the size of this buffer
    char **ch,           // the end of the last line written to the buffer by this thread
    size_t myMaxLineLen  // the longest line seen so far by this thread
  // Initial size for the thread's buffer is twice as big as needed for rowsPerBatch based on
  // maxLineLen from the sample; i.e. only 50% of the buffer should be used.
  // If we get to 75% used, we'll realloc.
  // i.e. very cautious and grateful to the OS for not fetching untouched pages of buffer.
  // Plus, more caution ... myMaxLineLine is tracked and if that grows we'll realloc too.
  // Very long lines are caught up front and rowsPerBatch is set to 1 in that case.
  // This checkBuffer() is called after every line.
) {
  size_t thresh = 0.75*(*myAlloc);
  
  if ((*ch > (*buffer)+thresh) || (rowsPerBatch*myMaxLineLen > thresh )) {
    size_t off = *ch-*buffer;
    *myAlloc = 1.5*(*myAlloc);
    *buffer = realloc(*buffer, *myAlloc);
    *ch = *buffer+off;  // in case realloc moved the allocation
  }
}

SEXP fwriteMain(SEXP MAT,   //matrix test
                SEXP filename_Arg,
                SEXP sep_Arg,
                SEXP eol_Arg,
                SEXP dec_Arg,
                SEXP buffMB_Arg)         // [1-1024] default 8MB
{
  
  //These settings are from fWriteR.c originally.
  const char *FILENAME = CHAR(STRING_ELT(filename_Arg, 0));
  int64_t NROW = nrows(MAT);
  int NCOL = ncols(MAT);
  sep = *CHAR(STRING_ELT(sep_Arg, 0));
  dec = *CHAR(STRING_ELT(dec_Arg,0));
  const char *EOL = CHAR(STRING_ELT(eol_Arg, 0));
  int buffMB = INTEGER(buffMB_Arg)[0];
  
  //Get column names
  SEXP dimnames = getAttrib(MAT, R_DimNamesSymbol);
  SEXP cn = VECTOR_ELT(dimnames, 1);
  
  void *COLNAMES = (void *)DATAPTR(cn);
  
  
  // allocate new `columns` vector. Although this could be DATAPTR(DFcoerced) directly, it can't
  // because there's an offset on each column that points to (DATAPTR for each column) which fread.c
  // would need to know. Rather than have the complication of a new offset variable, we just alloc a
  // new vetcors of pointers directly. It won't make a difference to speed because only this new
  // vector need be used by fread.c.  It just uses a tiny bit more memory (ncol * 8 bytes).
  void **COLUMNS = (void *)R_alloc(NCOL, sizeof(SEXP));
  
  writer_fun_t *ARGSFUNS = funs;  // funs declared statically at the top of this file
  
  // Allocate and populate lookup vector to writer function for each column, whichFun[]
  uint8_t *WHICHFUN = (uint8_t *)R_alloc(NCOL, sizeof(uint8_t));
  
  //Type one column. All columns same type.
  //if(TYPEOF(&MAT[0])==REALSXP){
  //  wf = WF_Float64;
  //} else {
  //  wf = WF_Int32;
  //}
  
  switch(TYPEOF(MAT)) {
  case REALSXP:
    wf = WF_Float64;
    break;
  default:
    wf = WF_Int32;
  }
  
  
  if(TYPEOF(MAT)==REALSXP){
    //If matrix is doubles
    double *point = REAL(MAT);
    for (int j=0; j<NCOL; j++) {
      COLUMNS[j] = point;
      point+=NROW;
      WHICHFUN[j] = wf;
    }
  } else {
    //If matrix is integers
    int *point = INTEGER(MAT);
    for (int j=0; j<NCOL; j++) {
      COLUMNS[j] = point;
      point+=NROW;
      WHICHFUN[j] = wf;
    }
  }
  
  //This is back to the original fwritemain function
  
  // Estimate max line length of a 1000 row sample (100 rows in 10 places).
  // 'Estimate' even of this sample because quote='auto' may add quotes and escape embedded quotes.
  // Buffers will be resized later if there are too many line lengths outside the sample, anyway.
  // maxLineLen is required to determine a reasonable rowsPerBatch.
  
  
  // alloc one buffMB here.  Keep rewriting each field to it, to sum up the size.  Restriction: one field can't be
  // greater that minimumum buffMB (1MB = 1 million characters).  Otherwise unbounded overwrite. Possible with very
  // very long single strings, or very long list column values.
  // The caller guarantees no field with be longer than this. If so, it can set buffMB larger. It might know
  // due to some stats it has maintained on each column or in the environment generally.
  // However, a single field being longer than 1 million characters is considered a very reasonable restriction.
  // Once we have a good line length estimate, we may increase the buffer size a lot anyway.
  // The default buffMB is 8MB,  so it's really 8 million character limit by default. 1MB is because user might set
  // buffMB to 1, say if they have 512 CPUs or more, perhaps.
  
  // Cold section as only 1,000 rows. Speed not an issue issue here.
  // Overestimating line length is ok.
  int eolLen = strlen(EOL);
  if (eolLen<=0) STOP("eol must be 1 or more bytes (usually either \\n or \\r\\n) but is length %d", eolLen);
  
  //  int buffMB = args.buffMB;
  if (buffMB<1 || buffMB>1024) STOP("buffMB=%d outside [1,1024]", buffMB);
  size_t buffSize = (size_t)1024*1024*buffMB;
  char *buff = malloc(buffSize);
  if (!buff) STOP("Unable to allocate %dMB for line length estimation: %s", buffMB, strerror(errno));
  
  
  int maxLineLen = 0;
  int step = NROW<1000 ? 100 : NROW/10;
  for (int64_t start=0; start<NROW; start+=step) {
    int64_t end = (NROW-start)<100 ? NROW : start+100;
    for (int64_t i=start; i<end; i++) {
      int thisLineLen=0;
      for (int j=0; j<NCOL; j++) {
        char *ch = buff;                // overwrite each field at the beginning of buff to be more robust to single fields > 1 million bytes
        ARGSFUNS[WHICHFUN[j]]( COLUMNS[j], i, &ch );
        thisLineLen += (int)(ch-buff) + 1/*sep*/;        // see comments above about restrictions/guarantees/contracts
      }
      if (thisLineLen > maxLineLen) maxLineLen = thisLineLen;
    }
  }
  maxLineLen += eolLen;
  
  
  // open file in system specific manner. If it fails, throw an error.
  int f=-1;
  
#ifdef WIN32
  f = _open(FILENAME, _O_WRONLY | _O_BINARY | _O_CREAT, _S_IWRITE);
  // O_BINARY rather than O_TEXT for explicit control and speed since it seems that write() has a branch inside it
  // to convert \n to \r\n on Windows when in text mode not not when in binary mode.
#else
  f = open(FILENAME, O_WRONLY | O_CREAT, 0666);
  // There is no binary/text mode distinction on Linux and Mac
#endif
  
  if (f == -1) {
    int erropen = errno;
    STOP(access( FILENAME, F_OK ) != -1 ?
           "%s: '%s'. Failed to open existing file for writing. Do you have write permission to it? Is this Windows and does another process such as Excel have it open?" :
           "%s: '%s'. Unable to create new file for writing (it does not exist already). Do you have permission to write here, is there space on the disk and does the path exist?",
           strerror(erropen), FILENAME);
  }
  
  
  // WRITE COLUMN NAMES IF TRUE
  if (COLNAMES) {
    // We don't know how long this line will be.
    // It could be (much) longer than the data row line lengths
    // To keep things simple we'll reuse the same buffer used above for each field, and write each column name separately to the file.
    // If multiple calls to write() is ever an issue, we'll come back to this. But very unlikely.
    char *ch = buff;
    
    for (int j=0; j<NCOL; j++) {
      writeString(COLNAMES, j, &ch);
      WRITE(f, buff, (int)(ch-buff));
      ch = buff;  // overwrite column names at the start in case they are > 1 million bytes long
      *ch++ = sep;  // this sep after the last column name won't be written to the file
    }
    
    WRITE(f, EOL, eolLen);
  }
  free(buff);  // TODO: also to be free'd in cleanup when there's an error opening file above
  
  
  // Decide buffer size and rowsPerBatch for each thread
  // Once rowsPerBatch is decided it can't be changed, but we can increase buffer size if the lines
  // turn out to be longer than estimated from the sample.
  // buffSize large enough to fit many lines to i) reduce calls to write() and ii) reduce thread sync points
  // It doesn't need to be small in cache because it's written contiguously.
  // If we don't use all the buffer for any reasons that's ok as OS will only getch the cache lines touched.
  // So, generally the larger the better up to max filesize/nth to use all the threads. A few times
  //   smaller than that though, to achieve some load balancing across threads since schedule(dynamic).
  if (maxLineLen > buffSize) buffSize=2*maxLineLen;  // A very long line; at least 1,048,576 characters (since min(buffMB)==1)
  rowsPerBatch =
    (10*maxLineLen > buffSize) ? 1 :  // very very long lines (100,000 characters+) each thread will just do one row at a time.
    0.5 * buffSize/maxLineLen;        // Aim for 50% buffer usage. See checkBuffer for comments.
  if (rowsPerBatch > NROW) rowsPerBatch = NROW;
  
  
  
  
  
  char *ch, *myBuff;               // local to each thread
  ch = myBuff = malloc(buffSize);  // each thread has its own buffer. malloc and errno are thread-safe.
  
  size_t myAlloc = buffSize;
  size_t myMaxLineLen = maxLineLen;
  // so we can realloc(). Should only be needed if there are very long lines that are
  // much longer than occurred in the sample for maxLineLen; e.g. unusally long string values
  // that didn't occur in the sample, or list columns with some very long vectors in some cells.
  
  for(int64_t start=0; start<NROW; start+=rowsPerBatch) {
    int64_t end = ((NROW - start)<rowsPerBatch) ? NROW : start + rowsPerBatch;
    for (int64_t i=start; i<end; i++) {
      char *lineStart = ch;
      // Tepid starts here (once at beginning of each per line)
      
      // Hot loop
      for (int j=0; j<NCOL; j++) {
        (ARGSFUNS[WHICHFUN[j]])(COLUMNS[j], i, &ch);
        *ch++ = sep;
      }
      // Tepid again (once at the end of each line)
      ch--;  // backup onto the last sep after the last column. ncol>=1 because 0-columns was caught earlier.
      write_chars(EOL, &ch);  // overwrite last sep with eol instead
      
      // Track longest line seen so far. If we start to see longer lines than we saw in the
      // sample, we'll realloc the buffer. The rowsPerBatch chosen based on the (very good) sample,
      // must fit in the buffer. Can't early write and reset buffer because the
      // file output would be out-of-order. Can't change rowsPerBatch after the 'parallel for' started.
      size_t thisLineLen = ch-lineStart;
      if (thisLineLen > myMaxLineLen) myMaxLineLen=thisLineLen;
      checkBuffer(&myBuff, &myAlloc, &ch, myMaxLineLen);
    }
    
    
    WRITE(f, myBuff, (int)(ch-myBuff));
    
    ch = myBuff;  // back to the start of my buffer ready to fill it up again
  }
  
  free(myBuff);
  CLOSE(f);
  
  return(R_NilValue);
}
