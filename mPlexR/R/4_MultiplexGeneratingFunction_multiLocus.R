###############################################################################
#    __  __       _ _   _       _                          _               _
#   |  \/  |_   _| | |_(_)_ __ | | _____  __     _ __ ___ | |    ___   ___(_)
#   | |\/| | | | | | __| | '_ \| |/ _ \ \/ /____| '_ ` _ \| |   / _ \ / __| |
#   | |  | | |_| | | |_| | |_) | |  __/>  <_____| | | | | | |__| (_) | (__| |
#   |_|  |_|\__,_|_|\__|_| .__/|_|\___/_/\_\    |_| |_| |_|_____\___/ \___|_|
#                        |_|
###############################################################################

#' mPlex Multiple Loci Offspring Reference
#'
#' Create a list specifying the offspring probability distribution.
#'
#' @usage MakeReference_Multiplex_mLoci(H, R, S, d)
#'
#' @param H Vector of homing rates for each drive piece
#' @param R Vector of deleterious allele generation rates
#' @param S Vector of neutral allele generation rates
#' @param d Vector of background mutation rates at each locus
#'
#' @details This function creates a reference list for \code{\link{MultiplexOffspring_mLoci}}.
#' Each drive element targets one locus. Each locus is independent of the rest.
#' The number of targets is specified by the length of H. R,S, and d must
#' be the same length as H, but will generally be the same number replicated that
#' many times. It is assumed that S is R/3, but this can be varied.
#' This function is similar to \code{\link{MakeReference_DaisyDrive}} and
#' \code{\link{MakeReference_Multiplex_oLocus}}
#'
#' @return list of homing and mendelian genotypes and rates
#'
#' @examples
#' H <- c(0.9,0.4,0.7) # This drive targets 3 loci
#' R <- c(0.001, 0.002, 0.003)
#' S <- c(0.0003, 0.0006, 0.001)
#' d <- c(0.0001, 0.0001, 0.0001)
#'
#' MakeReference_Multiplex_mLoci(H,R,S,d)
#'
#' @export
MakeReference_Multiplex_mLoci <- function(H=c(0.9, 0.4, 0.7),R=c(0.0, 0.0, 0.0), S=R/3, d=c(0.0001, 0.0001, 0.0001)){

  #H is homing rate. The length of this vector determines the number of loci
  # in the multiplex drive. Each drive can have the same or different rates.

  #R is the NHEJ rate for deleterious alleles. Must be same length as H,
  # can be the same or different values.

  #S is the NHEJ rate for neutral alleles. Must be the same length as H,
  # can be the same or different values.

  #d is the background mutation rate. Must be the same length as H, can
  # have the same or different values.


  #Safety checks
  if(any( c(length(H),length(R), length(S), length(d)) != length(H))){
    return(cat("All inputs must be the same length!\n",
           "i.e. length(H) == length(R) == length(S) == length(d)"))
  }
  if(any(H>1, R>1, S>1, d>1)){
    return(cat("All rates must be less than or equal to 1\n"))
  }
  if(any((d+H) > 1)){
    return(cat("Homing rates plus background mutation rates must be <= 1\n",
           "i.e. H+d <= 1\n"))
  }
  if(any((R+S) > 1)){
    return(cat("Negative and neutral repair rates must sum to <= 1\n",
           "i.s. R+S <= 1"))
  }


  #setup allele letters
  #W = Wild-type
  #H = Homing
  #R = Deleterious resistant
  #S = Neutral resistant
  gtype <- c("W", "H", "R", "S")

  #matrix to hold homing probs, then fill it
  homingProbs <- matrix(data = 0, nrow = 4, ncol = length(H), dimnames = list(gtype, NULL))

  homingProbs[1, ] <- 1-d-H #chance to stay W is 1-homing-background mutation
  homingProbs[2, ] <- H*(1-R-S) #chance to become homing is H*1-H*R-H*S
  homingProbs[3, ] <- H*R   #NHEJ caused resistance, detrimentalt allele
  homingProbs[4, ] <- d+H*S #good resistant allele, from NHEJ and background mutation rate

  #set up lists to hold probabilities
  mendProbsList <- vector(mode = "list", length = length(H))
  homProbsList <- vector(mode = "list", length = length(H))

  #fill the lists
  for(i in 1:length(H)){
    #Mendelian Probabilities
    mendProbsList[[i]]$W <- setNames(object = c(1-d[i], d[i]), nm = c("W", "S"))
    mendProbsList[[i]]$H <- setNames(object = c(1-d[i], d[i]), nm = c("H", "S"))
    mendProbsList[[i]]$R <- 1
    mendProbsList[[i]]$S <- 1

    #Homing Probabilities
    homProbsList[[i]]$W <- homingProbs[ ,i]
    homProbsList[[i]]$H <- setNames(object = c(1-d[i], d[i]), nm = c("H", "S"))
    homProbsList[[i]]$R <- 1
    homProbsList[[i]]$S <- 1
  }

  return(list(
    mendelian = mendProbsList,
    homing = homProbsList))

}

#' mPlex Multiple Loci Offspring
#'
#' Create a list of offspring genotypes and their probabilities
#'
#' @usage MultiplexOffspring_mLoci(fGen, mGen, reference)
#'
#' @param fGen Female genotype
#' @param mGen Male genotype
#' @param reference Offspring reference list
#'
#' @details Using the reference generated by \code{\link{MakeReference_Multiplex_mLoci}},
#' this function expands the possible genotypes of the offspring and the ratios
#' that they occur. Similar to \code{\link{DaisyOffspring}} and
#' \code{\link{MultiplexOffspring_oLocus}}.
#'
#' @return List(Alleles, Probabilities)
#'
#' @examples
#' ref <- MakeReference_Multiplex_mLoci(H = 0.98, R = 0.001, S = 0.0003, d = .00001)
#' fGen <- "WW"
#' mGen <- "WW"
#'
#' MultiplexOffspring_mLoci(fGen, mGen, ref)
#'
#' @export
MultiplexOffspring_mLoci <- function(fGen, mGen, reference){

  if(nchar(fGen) != nchar(mGen)){
    return(cat("Critters have different number of loci.\nCheck their genotypes."))
  }

  #split mother genotype
  #This splits all characters.
  private$fSplit <- strsplit(x = fGen, split = "")[[1]]
  private$mSplit <- strsplit(x = mGen, split = "")[[1]]

  #get number of alleles. Divide by two because diploid
  private$numAlleles <- length(private$fSplit)/2

  #make a list of each allele at every locus. This list is length private$numAlleles, and each
  # sublist has length 2
  private$momAlleles <- lapply(X = seq.int(from = 1, to = 2*private$numAlleles, by = 2), FUN = function(X){private$fSplit[X:(X+1)]})
  private$dadAlleles <- lapply(X = seq.int(from = 1, to = 2*private$numAlleles, by = 2), FUN = function(X){private$mSplit[X:(X+1)]})

  #score them
  private$fScore <- grepl(pattern = "H", x = private$momAlleles, ignore.case = FALSE, perl = FALSE, fixed = TRUE)
  private$mScore <- grepl(pattern = "H", x = private$dadAlleles, ignore.case = FALSE, perl = FALSE, fixed = TRUE)

  #setup offspring allele lists
  private$fAllele <- rep(x = list(vector(mode = "list", 2)), private$numAlleles)
  private$fProbs <- rep(x = list(vector(mode = "list", 2)), private$numAlleles)
  private$mAllele <- rep(x = list(vector(mode = "list", 2)), private$numAlleles)
  private$mProbs <- rep(x = list(vector(mode = "list", 2)), private$numAlleles)

  #loop over all loci
  for(i in 1:private$numAlleles){

    #Females!
    if(private$fScore[i]){
      #If there is homing
      #loop over alleles at the locus. Everything is diploid here.
      for(j in 1:2){

        #Fill allele with letter and probs
        if(private$momAlleles[[i]][[j]]=="W"){
          private$fAllele[[i]][[j]] <- c("W","H","R","S")
          private$fProbs[[i]][[j]] <- reference$homing[[i]]$W
        } else if(private$momAlleles[[i]][[j]]=="H"){
          private$fAllele[[i]][[j]] <- c("H", "S")
          private$fProbs[[i]][[j]] <- reference$homing[[i]]$H
        } else if(private$momAlleles[[i]][[j]]=="R"){
          private$fAllele[[i]][[j]] <- "R"
          private$fProbs[[i]][[j]] <- reference$homing[[i]]$R
        } else if(private$momAlleles[[i]][[j]]=="S"){
          private$fAllele[[i]][[j]] <- "S"
          private$fProbs[[i]][[j]] <- reference$homing[[i]]$S
        }

      }#end allele loop
    } else {
      #If there is not homing
      #loop over alleles at the locus. Everything is diploid here.
      for(j in 1:2){

        #Fill allele with letter and probs
        if(private$momAlleles[[i]][[j]]=="W"){
          private$fAllele[[i]][[j]] <- c("W","S")
          private$fProbs[[i]][[j]] <- reference$mendelian[[i]]$W
        } else if(private$momAlleles[[i]][[j]]=="H"){
          private$fAllele[[i]][[j]] <- c("H", "S")
          private$fProbs[[i]][[j]] <- reference$mendelian[[i]]$H
        } else if(private$momAlleles[[i]][[j]]=="R"){
          private$fAllele[[i]][[j]] <- "R"
          private$fProbs[[i]][[j]] <- reference$mendelian[[i]]$R
        } else if(private$momAlleles[[i]][[j]]=="S"){
          private$fAllele[[i]][[j]] <- "S"
          private$fProbs[[i]][[j]] <- reference$mendelian[[i]]$S
        }

      }#end allele loop
    }#end female if statement

    #Males!
    if(private$mScore[i]){
      #If there is homing
      #loop over alleles at the locus. Everything is diploid here.
      for(j in 1:2){

        #Fill allele with letter and probs
        if(private$dadAlleles[[i]][[j]]=="W"){
          private$mAllele[[i]][[j]] <- c("W","H","R","S")
          private$mProbs[[i]][[j]] <- reference$homing[[i]]$W
        } else if(private$dadAlleles[[i]][[j]]=="H"){
          private$mAllele[[i]][[j]] <- c("H", "S")
          private$mProbs[[i]][[j]] <- reference$homing[[i]]$H
        } else if(private$dadAlleles[[i]][[j]]=="R"){
          private$mAllele[[i]][[j]] <- "R"
          private$mProbs[[i]][[j]] <- reference$homing[[i]]$R
        } else if(private$dadAlleles[[i]][[j]]=="S"){
          private$mAllele[[i]][[j]] <- "S"
          private$mProbs[[i]][[j]] <- reference$homing[[i]]$S
        }

      }#end allele loop
    } else {
      #If there is not homing
      #loop over alleles at the locus. Everything is diploid here.
      for(j in 1:2){

        #Fill allele with letter and probs
        if(private$dadAlleles[[i]][[j]]=="W"){
          private$mAllele[[i]][[j]] <- c("W","S")
          private$mProbs[[i]][[j]] <- reference$mendelian[[i]]$W
        } else if(private$dadAlleles[[i]][[j]]=="H"){
          private$mAllele[[i]][[j]] <- c("H", "S")
          private$mProbs[[i]][[j]] <- reference$mendelian[[i]]$H
        } else if(private$dadAlleles[[i]][[j]]=="R"){
          private$mAllele[[i]][[j]] <- "R"
          private$mProbs[[i]][[j]] <- reference$mendelian[[i]]$R
        } else if(private$dadAlleles[[i]][[j]]=="S"){
          private$mAllele[[i]][[j]] <- "S"
          private$mProbs[[i]][[j]] <- reference$mendelian[[i]]$S
        }

      }#end allele loop
    }#end male if statement
  }#end loci loop


  #combine each locus into single lists, so that alleles within a locus can't
  # be combined with each other, but do get combined with allelels for the
  # other loci.
  # ie, unlist the sublists in each allele/probs list. This will give single-
  # depth lists the same length as the number of multiplex loci.
  private$fAllLoci <- lapply(X = private$fAllele, FUN = unlist, recursive=TRUE)
  private$fProbsLoci <- lapply(X = private$fProbs, FUN = unlist, recursive=TRUE)
  private$mAllLoci <- lapply(X = private$mAllele, FUN = unlist, recursive=TRUE)
  private$mProbsLoci <- lapply(X = private$mProbs, FUN = unlist, recursive=TRUE)

  #combine male and female alleles at each locus.
  # This requires looping through each locus, getting all combinations of
  private$lociAList <- vector(mode = "list", length = private$numAlleles)
  private$lociPList <- vector(mode = "list", length = private$numAlleles)

  for( i in 1:private$numAlleles){

    #get all combinationes of male/female for each allele
    private$holdAllOne <- expand.grid(private$fAllLoci[[i]], private$mAllLoci[[i]], KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)
    private$holdProbOne <- expand.grid(private$fProbsLoci[[i]], private$mProbsLoci[[i]], KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)

    #sort each combination so they are the same.
    private$holdAllOne <- apply(X = private$holdAllOne, MARGIN = 1, FUN = sort)

    #paste alleles togheter
    private$holdAllTwo <- do.call(what = "paste0", list(private$holdAllOne[1, ], private$holdAllOne[2, ]))
    private$holdProbTwo <- private$holdProbOne[ ,1]*private$holdProbOne[ ,2]

    #aggregate and return
    private$aggregateHold <- aggregate(private$holdProbTwo~private$holdAllTwo, data=data.frame(private$holdAllTwo, private$holdProbTwo), FUN=sum)

    #fill lists
    private$lociAList[[i]] <- as.character(private$aggregateHold$'private$holdAllTwo')
    private$lociPList[[i]] <- private$aggregateHold$'private$holdProbTwo'

  }


  #get all combinations of each loci. This gives the total genotype
  private$outAList <- expand.grid(private$lociAList, KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)
  private$outPList <- expand.grid(private$lociPList, KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)

  #combine allele names and probabilities
  private$outAList <- apply(X = private$outAList, MARGIN = 1, FUN = paste0, collapse="")
  private$outPList <- apply(X = private$outPList, MARGIN = 1, FUN = prod)
  #can use matrixStats::rowProds(x = as.matrix(private$outPList))


  #normalize probs and return
  private$offspring <- list(
    Alleles = private$outAList,
    Probabilities = private$outPList/sum(private$outPList)
  )

}
