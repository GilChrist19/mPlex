---
title: "mPlex Daisy Drive Example"
#output: rmarkdown::pdf_document
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{mPlex-daisy}
  %\VignetteEncoding{UTF-8}
---

```{css, echo = FALSE}
pre {
  white-space: pre !important;
  overflow-y: scroll !important;
  max-height: 25vh !important;
}

# reference
#  https://stackoverflow.com/questions/41135085/how-to-make-vertical-scrollbar-appear-in-rmarkdown-code-chunks-html-view
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  hold = TRUE,
  fig.width = 7,
  fig.height = 10.5,
  eval = TRUE
)
```


## mPlex - Daisy-Chain Inheritance Simulation

The [Daisy Chain gene drive](https://doi.org/10.1073/pnas.1716358116) is a creation 
of [Keven Esvelt](http://www.sculptingevolution.org/kevin-m-esvelt) and [Martin Nowak](http://www.martinnowak.com/). 
This drive purportedly provides local control over the spread of a gene drive. As 
implemented in *mPlex*, the first piece drives the second, the second drives the third, 
and so on. We have already covered the basics of setting-up, running, and analyzing 
simulations in *mPlex*, using a [multiplex](mPlex_mLoc.html) inheritance design, so 
here we explore scenarios using a Daisy-Chain of differing lengths. 

### Daisy-Chain with One Link

The first piece of a Daisy-Chain is not driven by any other piece, therefore it 
follows standard mendelian behavior. Here, we will explore two scenarios: basic 
Mendelian inheritance, and Mendelian inheritance demonstrating a heterozygous 
advantage. These two examples match the first 3 examples provided with [MGDrivE](https://cran.r-project.org/package=MGDrivE), 
in the *MGDrivE-Examples* vignette. These simulations are performed in 1, well-mixed 
population. 

#### Basic Mendelian Inheritance

First, we explore a one-piece Daisy-Chain with no fitness costs. 

```{r, eval=TRUE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, "aggDir")
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 1-node network, ie, just one, well-mixed population
sitesNumber <- 1
moveMat <- as.matrix(1)


####################
# Inheritance pattern
####################
# a 1-locus Daisy behaves like a Mendelian drive, and we add no extra costs to 
#  it here, along with no background mutations
reproductionReference <- MakeReference_DaisyDrive(H = c(0),
                                                  R = c(0),
                                                  S = c(0),
                                                  d = c(0))


####################
# Setup Initial genotype ratios
####################
# 1 locus, start completely wild-type
alleloTypes <- vector(mode = "list", length = 1L) #1 locus
alleloTypes[[1]]$alleles <- c("W")
alleloTypes[[1]]$probs <- c(1)

# replicate so each patch starts the same
AllAlleles <- replicate(n = sitesNumber, expr = alleloTypes, simplify = FALSE)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
patchReleases[[1]]$maleReleases <- basicRepeatedReleases(releaseStart = 25,
                                         releaseEnd = 26,
                                         releaseInterval = 1,
                                         genMos = c("HH"),
                                         numMos = c(10),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365,
                           sampTime = 2,
                           AdPopEQ = 500,
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 5, tLarva = 6, tPupa = 4, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 1,
         numReps = 5, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "DaisyDrive",
         verbose = FALSE)


####################
# Post Analysis
####################
# setup aggregation key
#  this example sets all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir, "0_AggKey.csv"), 
                  genotypes = list(NULL), collapse = c(FALSE))


# aggregate experiment by aggregation key
simAggregation(readDirectory = simDir, writeDirectory = aggDir, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)


# plot for example
plotmPlexSingle(directory = aggDir, whichPatches = NULL, nonZeroGen = FALSE)
plotmPlexMult(directory = aggDir,whichPatches = NULL, nonZeroGen = FALSE, lwd=0.35,alpha=0.75)
```

```{r, eval=TRUE, include = FALSE}
aggKey <- read.csv(file = file.path(aggDir, "0_AggKey.csv"), header = TRUE, 
                   stringsAsFactors = FALSE)
aggKey
```

Looking at the plots, we see that only 3 genotypes are represented. These represent 
the three genotypes we expect: 10 is `r aggKey$Key[10]`, 1 is `r aggKey$Key[1]`, 
and 4 is `r aggKey$Key[4]`, the heterozygote. We see the initial release of `r aggKey$Key[1]` 
in the males, then the formation of heterozygotes, since it remains at such a low 
frequency. However, it doesn't die out, becuase there is no fitness cost on any of 
the pieces.

```{r, echo=FALSE}
####################
# Cleanup before next run
####################
unlink(x = outFolder, recursive = TRUE)
rm(list=ls())
```


#### Mendelian Inheritance with a Fitness Cost

Our second exploration will again have Mendelian inheritance, but now with a fitness 
cost. We apply a 40% fitness cost on the homozygotes, pushing the population to 
be almost completely heterozygous. Additionally, we will increase the size and number 
of releases to speed up the process.

```{r, eval=TRUE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, "aggDir")
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 1-node network, ie, just one, well-mixed population
sitesNumber <- 1
moveMat <- as.matrix(1)


####################
# Inheritance pattern
####################
# a 1-locus Daisy behaves like a Mendelian drive, but we add an extra cost to 
#  the homozygotes, along with no background mutations

# These genotypes correspond to ones in the cube. Look at a base cube first,
#  then set this.
# homozygotes are 60% as fit as heterozygote over their entire lifetime
#  Since omega is the adult daily death rate, we use the built-in function to
#  calculate our desired lifetime cost as applied daily
dayOmega <- calcOmega(mu = 0.09, lifespanReduction = 0.60)
omegaNew <- c("HH"=dayOmega, "WW"=dayOmega)
reproductionReference <- MakeReference_DaisyDrive(H = c(0),
                                                  R = c(0),
                                                  S = c(0),
                                                  d = c(0),
                                                  omega = omegaNew)


####################
# Setup Initial genotype ratios
####################
# 1 locus, start completely wild-type
alleloTypes <- vector(mode = "list", length = 1L) #1 locus
alleloTypes[[1]]$alleles <- c("W")
alleloTypes[[1]]$probs <- c(1)

# replicate so each patch starts the same
AllAlleles <- replicate(n = sitesNumber, expr = alleloTypes, simplify = FALSE)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
releaseVec <- basicRepeatedReleases(releaseStart = 100,
                                         releaseEnd = 100,
                                         releaseInterval = 0,
                                         genMos = c("HH"),
                                         numMos = c(50),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

patchReleases[[1]]$maleReleases <- releaseVec
patchReleases[[1]]$femaleReleases <- releaseVec

# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365*2,
                           sampTime = 2,
                           AdPopEQ = 500,
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 5, tLarva = 6, tPupa = 4, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 1,
         numReps = 5, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "DaisyDrive",
         verbose = FALSE)


####################
# Post Analysis
####################
# setup aggregation key
#  this example sets all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir, "0_AggKey.csv"), 
                  genotypes = list(NULL), collapse = c(FALSE))


# aggregate experiment by aggregation key
simAggregation(readDirectory = simDir, writeDirectory = aggDir, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)


# plot for example
plotmPlexSingle(directory = aggDir, whichPatches = NULL, nonZeroGen = FALSE)
plotmPlexMult(directory = aggDir,whichPatches = NULL, nonZeroGen = FALSE, lwd=0.35,alpha=0.75)
```

```{r, eval=TRUE, include = FALSE}
aggKey <- read.csv(file = file.path(aggDir, "0_AggKey.csv"), header = TRUE, 
                   stringsAsFactors = FALSE)
aggKey
```

Notice the different final genotype ratios, where `r aggKey$Key[4]`, the heterozygote, 
is the dominant species. Compare this to the third simulation from *MGDrivE*, as an 
indication of agreement between the two models.

```{r, echo=FALSE}
####################
# Cleanup before next run
####################
unlink(x = outFolder, recursive = TRUE)
rm(list=ls())
```


### Daisy-Chain with Two Links

A two-piece Daisy-Chain implies one locus with a Cas9, inherited in a Mendelian 
fashion as shown above, driving a second, unlinked, locus through the population. 
This is exactly the same as the [split-drive](https://elifesciences.org/articles/51701) 
system from the [Akbari](https://www.akbarilab.com/) lab. Here, we reproduce the 
analysis from that paper, and then explore a novel suppression system based on 
the split-drive construct.

#### Split-Drive Replacement

We simulate a two-node landscape, where we perform releases in one population, 
and see how much it spreads into the other. Metrics of interest from the paper 
were the length of time the transgene (linked to the gRNA locus) was above 80% in 
the released population, and the extent to which either the Cas9 locus or the transgene 
spread into the second population. Here, we perform a similar analysis, looking for 
all individuals carrying the transgene, and then looking for all individuals without 
a modified allele. "Modified" allele is being taken to mean the transgene or any 
NHEJ events in the wild-type, where the transgene isn't present but it is also not 
the natural allele anymore.  

```{r, eval=TRUE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, paste0("aggDir", 1:2))
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 2-node network, with 1% migration per adult generation
#  * So, 26.11111 is the total generation time, and not the expected adult life-span
#  I'm not sure I agree with this, but it is what was used in the paper, so we will 
#  use it here.
sitesNumber <- 2
stayProbability <- 0.01 / 26.11111 # This is an entire generation, not the adult
moveMat <- matrix(data = c(1-stayProbability,stayProbability,stayProbability,1-stayProbability),
                  nrow = sitesNumber, ncol = sitesNumber)


####################
# Inheritance pattern
####################
# a 2-locus Daisy
cCost <- 0.078
fCost <- 0.11 * 0.09  # this is modified to the expected adult age
sNew <- c('HHHH'=1-2*cCost, 'HWHH'=1-cCost, 'HHHR'=1-2*cCost, 'HWHR'=1-cCost,
          'HHHS'=1-2*cCost, 'HWHS'=1-cCost, 'HHHW'=1-2*cCost, 'HWHW'=1-cCost,
          'HHRR'=1-2*cCost, 'HWRR'=1-cCost, 'HHRS'=1-2*cCost, 'HWRS'=1-cCost,
          'HHRW'=1-2*cCost, 'HWRW'=1-cCost, 'HHSS'=1-2*cCost, 'HWSS'=1-cCost,
          'HHSW'=1-2*cCost, 'HWSW'=1-cCost, 'HHWW'=1-2*cCost, 'HWWW'=1-cCost)
oNew <- c('HHHH'=1-fCost, 'HRHH'=1-fCost, 'HSHH'=1-fCost, 'HWHH'=1-fCost, 
          'RRHH'=1-fCost, 'RSHH'=1-fCost, 'RWHH'=1-fCost, 'SSHH'=1-fCost,
          'SWHH'=1-fCost, 'WWHH'=1-fCost, 'HHHS'=1-fCost, 'HRHS'=1-fCost,
          'HSHS'=1-fCost, 'HWHS'=1-fCost, 'RRHS'=1-fCost, 'RSHS'=1-fCost,
          'RWHS'=1-fCost, 'SSHS'=1-fCost, 'SWHS'=1-fCost, 'WWHS'=1-fCost,
          'HHSS'=1-fCost, 'HRSS'=1-fCost, 'HSSS'=1-fCost, 'HWSS'=1-fCost,
          'RRSS'=1-fCost, 'RSSS'=1-fCost, 'RWSS'=1-fCost, 'SSSS'=1-fCost,
          'SWSS'=1-fCost, 'WWSS'=1-fCost)
reproductionReference <- MakeReference_DaisyDrive(H = c(0.63425,0),
                                                  R = c(0.03611666,0),
                                                  S = c(0.18058333,0),
                                                  d = c(0,0),
                                                  s = sNew,
                                                  omega = oNew)

# parameter translation notes
#  The probabilities aren't calculated the same in MGDrivE and mPlex.
#  Here are the conversion equations, MGDrive = mPlex
#  H: Cut*Hom = H*(1-R-S)
#  R: Cut*(1-Hom)*rRate = H*R
#  S: Cut*(1-Hom)*(1-rRate) = H*S
#
# For this publication, these conversions imply:
#  Female Rates
#  H: 0.788
#  R: 0.0337
#  S: 0.1685
#  Male Rates
#  H: 0.4805
#  R: 0.0385333
#  S: 0.192666


####################
# Setup Initial genotype ratios
####################
# 2 locus, start completely wild-type
alleloTypes <- vector(mode = "list", length = 2L) #2 locus
alleloTypes[[1]]$alleles <- c("W")
alleloTypes[[1]]$probs <- c(1)
alleloTypes[[2]]$alleles <- c("W")
alleloTypes[[2]]$probs <- c(1)

# replicate so each patch starts the same
AllAlleles <- replicate(n = sitesNumber, expr = alleloTypes, simplify = FALSE)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
releaseVec <- basicRepeatedReleases(releaseStart = 100,
                                         releaseEnd = 163,
                                         releaseInterval = 7,
                                         genMos = c("HHHH"),
                                         numMos = c(250),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

patchReleases[[1]]$maleReleases <- releaseVec

# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365*12,
                           sampTime = 2,
                           AdPopEQ = 250,
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 5, tLarva = 6, tPupa = 4, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 2,
         numReps = 5, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "DaisyDrive",
         verbose = FALSE)


####################
# Post Analysis
####################
# setup aggregation key
#  this example sets all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir[1], "0_AggKey.csv"), 
                  genotypes = list(NULL,c('HH','HR','HS','HW')), collapse = c(TRUE,TRUE))
genOI_mLoci_Daisy(outputFile = file.path(aggDir[2], "0_AggKey.csv"), 
                  genotypes = list(c('WW'),NULL), collapse = c(TRUE,TRUE))

# aggregate experiment by aggregation key
for(agg in aggDir){
  simAggregation(readDirectory = simDir, writeDirectory = agg, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)
}

# plot for example
for(agg in aggDir){
  plotmPlexMult(directory = agg,whichPatches = NULL, nonZeroGen = FALSE, lwd=0.75,alpha=0.75)
}
```

Initially, there are several differences between *MGDrivE* and *mPlex* that we need 
to acknowledge. Drives are parameterized differently between models, reflecting 
the prevailing ideologies at the times of construction. Notes about transforming 
between parameter sets are provided in the above code. Additionally, *MGDrivE* has 
sex-specific parameters, which *mPlex* does not. Therefore, we have used the average 
of those parameters above, providing a slightly different result.  
  
The first plot shows all individuals with the transgene at the gRNA locus, either 
heterozygous or homozygous for it. Note the quick spread, taking over almost the 
entire population is under a year. This is in agreement with the published results. 
However, the transgene handily spreads into the second population, and doesn't begin 
to decline appreciably for almsot 10 years. This is in constrast to the original 
publication, where the transgene hardly spread into the second population, and was 
outnumbered by other alleles within 6 years.  
  
The second plot analyzes the individuals who carry any modified allele at the Cas9 
locus, be that the released allele, or any form of NHEJ event. The high initial spike 
is from the transgene release, and the slow decay later is due to fitness costs 
against the gRNAs and one NHEJ allele. There is a distinct lack of spread into the 
second population. This is an improvement over the published results, possibly stemming 
from the distorted generation of alleles, which have different costs in males and females, 
or from the smaller population size (250 individuals here, compared 
to 10000 in the publication), or simply a plotting artifact (the publication performs 
allele counts, where here we count individuals as wholes).

```{r, echo=FALSE}
####################
# Cleanup before next run
####################
unlink(x = outFolder, recursive = TRUE)
rm(list=ls())
```


#### Split-Drive Suppression

This is an extension of the original split-drive that now targets population 
suppression instead of population replacement. The drive functions in the same way, 
but now targets a female-fertility gene, such that there is a massive reproductive 
cost on females with the transgene. Additionally, as this drive is still speculative, 
the drive performance is increased to a nominal value that is not yet achievable, 
but should be by the final implementation. Additionally, the biological parameters 
describing the mosquito life-cycle have been modified, to reflect different conditions 
for growth.  
  
The metrics are similar in this instance. As the goal is population suppression, 
we will check how much the population declines in the first population. In the 
second population, we hope it declines very little, and will look for the spread 
of modified alleles.

```{r, eval=TRUE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, paste0("aggDir", 1:2))
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 2-node network, with 1% migration per adult generation
#  * So, 26.11111 is the total generation time, and not the expected adult life-span
#  I'm not sure I agree with this, but it is what was used in the paper, so we will 
#  use it here.
sitesNumber <- 2
stayProbability <- 0.01 * 0.09
moveMat <- matrix(data = c(1-stayProbability,stayProbability,stayProbability,1-stayProbability),
                  nrow = sitesNumber, ncol = sitesNumber)


####################
# Inheritance pattern
####################
# a 2-locus Daisy
cCost <- 0.078
fCost <- 0.11 * 0.09  # this is modified to the expected adult age
sNew <- c('HHHH'=0, 'HRHH'=0, 'HSHH'=0, 'HWHH'=0, 'RRHH'=0, 'RSHH'=0, 'RWHH'=0,
          'SSHH'=0, 'SWHH'=0, 'WWHH'=0, 'HHHS'=0, 'HRHS'=0, 'HSHS'=0, 'HWHS'=0,
          'RRHS'=0, 'RSHS'=0, 'RWHS'=0, 'SSHS'=0, 'SWHS'=0, 'WWHS'=0, 'HHHW'=0,
          'HRHW'=0, 'HSHW'=0, 'HWHW'=0, 'RRHW'=0, 'RSHW'=0, 'RWHW'=0, 'SSHW'=0,
          'SWHW'=0, 'WWHW'=0, 'HHSS'=0, 'HRSS'=0, 'HSSS'=0, 'HWSS'=0, 'RRSS'=0,
          'RSSS'=0, 'RWSS'=0, 'SSSS'=0, 'SWSS'=0, 'WWSS'=0)
oNew <- c('HHHH'=1-2*cCost-2*fCost, 'HRHH'=1-cCost-2*fCost, 'HSHH'=1-cCost-2*fCost,
          'HWHH'=1-cCost-2*fCost, 'RRHH'=1-2*fCost, 'RSHH'=1-2*fCost, 'RWHH'=1-2*fCost,
          'SSHH'=1-2*fCost, 'SWHH'=1-2*fCost, 'WWHH'=1-2*fCost, 'HHHR'=1-2*cCost-fCost,
          'HRHR'=1-cCost-fCost, 'HSHR'=1-cCost-fCost, 'HWHR'=1-cCost-fCost, 'RRHR'=1-fCost,
          'RSHR'=1-fCost, 'RWHR'=1-fCost, 'SSHR'=1-fCost, 'SWHR'=1-fCost, 'WWHR'=1-fCost,
          'HHHS'=1-2*cCost-fCost, 'HRHS'=1-cCost-fCost, 'HSHS'=1-cCost-fCost,
          'HWHS'=1-cCost-fCost, 'RRHS'=1-fCost, 'RSHS'=1-fCost, 'RWHS'=1-fCost,
          'SSHS'=1-fCost, 'SWHS'=1-fCost, 'WWHS'=1-fCost, 'HHHW'=1-2*cCost-fCost,
          'HRHW'=1-cCost-fCost, 'HSHW'=1-cCost-fCost, 'HWHW'=1-cCost-fCost,
          'RRHW'=1-fCost, 'RSHW'=1-fCost, 'RWHW'=1-fCost, 'SSHW'=1-fCost, 'SWHW'=1-fCost,
          'WWHW'=1-fCost, 'HHRR'=1-2*cCost, 'HRRR'=1-cCost, 'HSRR'=1-cCost, 'HWRR'=1-cCost,
          'HHRS'=1-2*cCost, 'HRRS'=1-cCost, 'HSRS'=1-cCost, 'HWRS'=1-cCost,
          'HHRW'=1-2*cCost, 'HRRW'=1-cCost, 'HSRW'=1-cCost, 'HWRW'=1-cCost,
          'HHSS'=1-2*cCost, 'HRSS'=1-cCost, 'HSSS'=1-cCost, 'HWSS'=1-cCost,
          'HHSW'=1-2*cCost, 'HRSW'=1-cCost, 'HSSW'=1-cCost, 'HWSW'=1-cCost,
          'HHWW'=1-2*cCost, 'HRWW'=1-cCost, 'HSWW'=1-cCost, 'HWWW'=1-cCost)
reproductionReference <- MakeReference_DaisyDrive(H = c(1,0),
                                                  R = c(0.00333,0),
                                                  S = c(0.01666,0),
                                                  d = c(0,0),
                                                  s = sNew,
                                                  omega = oNew)

# parameter translation notes
#  The probabilities aren't calculated the same in MGDrivE and mPlex.
#  Here are the conversion equations, MGDrive = mPlex
#  H: Cut*Hom = H*(1-R-S)
#  R: Cut*(1-Hom)*rRate = H*R
#  S: Cut*(1-Hom)*(1-rRate) = H*S
#
# For this publication, these conversions imply:
#  Rates
#  H: 1
#  R: 0.00333
#  S: 0.01666



####################
# Setup Initial genotype ratios
####################
# 2 locus, start completely wild-type
alleloTypes <- vector(mode = "list", length = 2L) #2 locus
alleloTypes[[1]]$alleles <- c("W")
alleloTypes[[1]]$probs <- c(1)
alleloTypes[[2]]$alleles <- c("W")
alleloTypes[[2]]$probs <- c(1)

# replicate so each patch starts the same
AllAlleles <- replicate(n = sitesNumber, expr = alleloTypes, simplify = FALSE)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
#  26 releases performed
releaseVec <- basicRepeatedReleases(releaseStart = 20,
                                         releaseEnd = 195,
                                         releaseInterval = 7,
                                         genMos = c("HHHH"),
                                         numMos = c(5000),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

patchReleases[[1]]$maleReleases <- releaseVec

# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365*1,
                           sampTime = 2,
                           AdPopEQ = 500,
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 2, tLarva = 5, tPupa = 1, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 2,
         numReps = 5, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "DaisyDrive",
         verbose = FALSE)


####################
# Post Analysis
####################
# setup aggregation key
#  this example sets all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir[1], "0_AggKey.csv"), 
                  genotypes = list(NULL,NULL), collapse = c(TRUE,TRUE))
genOI_mLoci_Daisy(outputFile = file.path(aggDir[2], "0_AggKey.csv"), 
                  genotypes = list('WW','WW'), collapse = c(TRUE,TRUE))

# aggregate experiment by aggregation key
for(agg in aggDir){
  simAggregation(readDirectory = simDir, writeDirectory = agg, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)
}

# plot for example
for(agg in aggDir){
  plotmPlexMult(directory = agg,whichPatches = NULL, nonZeroGen = FALSE, lwd=0.75,alpha=0.75)
}
```

The first plot shows the total population over the course of a year. We see the 
giant releases in the male population, corresponding to the 10x release sizes we 
performed. Looking at the female population, we clearly see the suppression happening 
in the first population. There is slight suppression in the second population, but 
it is hardly noticable.  

The second plot shows the amounts of wild-type individuals against any modified 
allele at either locus. Again looking at the females due to clarity, we see the 
initial population suppression, with transgenes and modified alleles taking over 
the population before fitness costs drive them out. Looking at the second population, 
we see that there is a sligh transmission of alleles from the first population, 
but it is significantly lower and also dies out over time.  

It is interesting that this analysis closely matches the exploration performed in 
*MGDrivE* for this same construct. The population size here is significantly reduced, 
due to compuational constraints. There is still male/female specific fitness costs, 
but now there are no sex-specific parameters dictating drive performance, so 
products are generated equally between males and females. Plotting metrics this time 
are also simpler, just looking at total population or non-wild-type alleles generated. 
Either of these two things could be the difference from above.

```{r, echo=FALSE}
####################
# Cleanup before next run
####################
unlink(x = outFolder, recursive = TRUE)
rm(list=ls())
```










### Daisy-Chain with Two Links

A two-piece Daisy-Chain implies one locus with a Cas9, inherited in a Mendelian 
fashion as shown above, driving a second, unlinked, locus through the population. 
This is exactly the same as the [split-drive](https://elifesciences.org/articles/51701) 
system from the [Akbari](https://www.akbarilab.com/) lab. Here, we reproduce the 
analysis from that paper, and then explore a novel suppression system based on 
the split-drive construct.




#### Daisy-Chain Gene Drive

This is an extension of the original split-drive that now targets population 
suppression instead of population replacement. The drive functions in the same way, 
but now targets a female-fertility gene, such that there is a massive reproductive 
cost on females with the transgene. Additionally, as this drive is still speculative, 
the drive performance is increased to a nominal value that is not yet achievable, 
but should be by the final implementation. Additionally, the biological parameters 
describing the mosquito life-cycle have been modified, to reflect different conditions 
for growth.  
  
The metrics are similar in this instance. As the goal is population suppression, 
we will check how much the population declines in the first population. In the 
second population, we hope it declines very little, and will look for the spread 
of modified alleles.

```{r, eval=TRUE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

outFolder <- "~/Desktop/OUTPUT/mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, paste0("aggDir", 1:2))
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 2-node network, with 1% migration per adult generation
#  * So, 26.11111 is the total generation time, and not the expected adult life-span
#  I'm not sure I agree with this, but it is what was used in the paper, so we will 
#  use it here.
sitesNumber <- 2
stayProbability <- 0.01 * 0.09
moveMat <- matrix(data = c(1-stayProbability,stayProbability,stayProbability,1-stayProbability),
                  nrow = sitesNumber, ncol = sitesNumber)


####################
# Inheritance pattern
####################
# a 2-locus Daisy
cCost <- 0.078
fCost <- 0.11 * 0.09  # this is modified to the expected adult age
sNew <- c('HHHH'=0, 'HRHH'=0, 'HSHH'=0, 'HWHH'=0, 'RRHH'=0, 'RSHH'=0, 'RWHH'=0,
          'SSHH'=0, 'SWHH'=0, 'WWHH'=0, 'HHHS'=0, 'HRHS'=0, 'HSHS'=0, 'HWHS'=0,
          'RRHS'=0, 'RSHS'=0, 'RWHS'=0, 'SSHS'=0, 'SWHS'=0, 'WWHS'=0, 'HHHW'=0,
          'HRHW'=0, 'HSHW'=0, 'HWHW'=0, 'RRHW'=0, 'RSHW'=0, 'RWHW'=0, 'SSHW'=0,
          'SWHW'=0, 'WWHW'=0, 'HHSS'=0, 'HRSS'=0, 'HSSS'=0, 'HWSS'=0, 'RRSS'=0,
          'RSSS'=0, 'RWSS'=0, 'SSSS'=0, 'SWSS'=0, 'WWSS'=0)
oNew <- c('HHHH'=1-2*cCost-2*fCost, 'HRHH'=1-cCost-2*fCost, 'HSHH'=1-cCost-2*fCost,
          'HWHH'=1-cCost-2*fCost, 'RRHH'=1-2*fCost, 'RSHH'=1-2*fCost, 'RWHH'=1-2*fCost,
          'SSHH'=1-2*fCost, 'SWHH'=1-2*fCost, 'WWHH'=1-2*fCost, 'HHHR'=1-2*cCost-fCost,
          'HRHR'=1-cCost-fCost, 'HSHR'=1-cCost-fCost, 'HWHR'=1-cCost-fCost, 'RRHR'=1-fCost,
          'RSHR'=1-fCost, 'RWHR'=1-fCost, 'SSHR'=1-fCost, 'SWHR'=1-fCost, 'WWHR'=1-fCost,
          'HHHS'=1-2*cCost-fCost, 'HRHS'=1-cCost-fCost, 'HSHS'=1-cCost-fCost,
          'HWHS'=1-cCost-fCost, 'RRHS'=1-fCost, 'RSHS'=1-fCost, 'RWHS'=1-fCost,
          'SSHS'=1-fCost, 'SWHS'=1-fCost, 'WWHS'=1-fCost, 'HHHW'=1-2*cCost-fCost,
          'HRHW'=1-cCost-fCost, 'HSHW'=1-cCost-fCost, 'HWHW'=1-cCost-fCost,
          'RRHW'=1-fCost, 'RSHW'=1-fCost, 'RWHW'=1-fCost, 'SSHW'=1-fCost, 'SWHW'=1-fCost,
          'WWHW'=1-fCost, 'HHRR'=1-2*cCost, 'HRRR'=1-cCost, 'HSRR'=1-cCost, 'HWRR'=1-cCost,
          'HHRS'=1-2*cCost, 'HRRS'=1-cCost, 'HSRS'=1-cCost, 'HWRS'=1-cCost,
          'HHRW'=1-2*cCost, 'HRRW'=1-cCost, 'HSRW'=1-cCost, 'HWRW'=1-cCost,
          'HHSS'=1-2*cCost, 'HRSS'=1-cCost, 'HSSS'=1-cCost, 'HWSS'=1-cCost,
          'HHSW'=1-2*cCost, 'HRSW'=1-cCost, 'HSSW'=1-cCost, 'HWSW'=1-cCost,
          'HHWW'=1-2*cCost, 'HRWW'=1-cCost, 'HSWW'=1-cCost, 'HWWW'=1-cCost)
reproductionReference <- MakeReference_DaisyDrive(H = c(1,0),
                                                  R = c(0.00333,0),
                                                  S = c(0.01666,0),
                                                  d = c(0,0),
                                                  s = sNew,
                                                  omega = oNew)

# parameter translation notes
#  The probabilities aren't calculated the same in MGDrivE and mPlex.
#  Here are the conversion equations, MGDrive = mPlex
#  H: Cut*Hom = H*(1-R-S)
#  R: Cut*(1-Hom)*rRate = H*R
#  S: Cut*(1-Hom)*(1-rRate) = H*S
#
# For this publication, these conversions imply:
#  Rates
#  H: 1
#  R: 0.00333
#  S: 0.01666



####################
# Setup Initial genotype ratios
####################
# 2 locus, start completely wild-type
alleloTypes <- vector(mode = "list", length = 2L) #2 locus
alleloTypes[[1]]$alleles <- c("W")
alleloTypes[[1]]$probs <- c(1)
alleloTypes[[2]]$alleles <- c("W")
alleloTypes[[2]]$probs <- c(1)

# replicate so each patch starts the same
AllAlleles <- replicate(n = sitesNumber, expr = alleloTypes, simplify = FALSE)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
#  26 releases performed
releaseVec <- basicRepeatedReleases(releaseStart = 20,
                                         releaseEnd = 195,
                                         releaseInterval = 7,
                                         genMos = c("HHHH"),
                                         numMos = c(5000),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

patchReleases[[1]]$maleReleases <- releaseVec

# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365*1,
                           sampTime = 2,
                           AdPopEQ = 500,
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 2, tLarva = 5, tPupa = 1, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 2,
         numReps = 5, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "DaisyDrive",
         verbose = TRUE)


####################
# Post Analysis
####################
# setup aggregation key
#  this example sets all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir[1], "0_AggKey.csv"), 
                  genotypes = list(NULL,NULL), collapse = c(TRUE,TRUE))
genOI_mLoci_Daisy(outputFile = file.path(aggDir[2], "0_AggKey.csv"), 
                  genotypes = list('WW','WW'), collapse = c(TRUE,TRUE))

# aggregate experiment by aggregation key
for(agg in aggDir){
  simAggregation(readDirectory = simDir, writeDirectory = agg, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)
}

# plot for example
for(agg in aggDir){
  plotmPlexMult(directory = agg,whichPatches = NULL, nonZeroGen = FALSE, lwd=0.75,alpha=0.75)
}
```















































### Small Genotype Example

In this second example, we will provide fitness costs for some of the genotypes, change the initial conditions of the patches, and modify the releases.  

  * `omega`: Adult mortality. We provide a cost so that two of the genotypes are less fit than the wild-type
    * `HH`: Homozygous homing individuals are only 50% as fit as wild-type
    * `RR`: Homozygous resistant 1 individuals are 90% as fit as wild-type
  * `aTypes3`: The third population begins as a mix of `W`, `R`, and `S` alleles, in the provided proportions
  * `rel2`: A second release is performed in the first patch, integrating `RR` individuals at time = 100
  * `AdPopEQ`: Patches are now different sizes, with the adult populations set as 100, 200, and 300
  * `sampTime`: We sample every other day by setting the `sampTime` parameter as 2

```{r, eval=TRUE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, "aggDir")
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 3-node network with 2% per day migration rate
#  Remember, rows need to sum to 1.
sitesNumber <- 3
moveMat <- matrix(data = c(0.98, 0.02, 0,
                           0.02, 0.98, 0,
                           0, 0, 1), nrow = sitesNumber, ncol = sitesNumber, byrow = TRUE)


####################
# Inheritance pattern
####################
# 1-locus CRISPR-like drive system
#  97% homing rate, 3% resistance rate, no backgorund mutation
reproductionReference <- MakeReference_Multiplex_mLoci(H = c(0.97),
                                                       R = c(0.03),
                                                       S = c(0),
                                                       d = c(0), omega = c("HH"=0.5, "RR" = 0.9))


####################
# Setup Initial genotype ratios
####################
# 1 locus, start completely wild-type in patches 1 and 2
#  start with a mixture in patch 3
aTypes1 <- vector(mode = "list", length = 1L) #1 locus
aTypes1[[1]]$alleles <- c("W")
aTypes1[[1]]$probs <- c(1L)
aTypes3 <- vector(mode = "list", length = 1L) #1 locus
aTypes3[[1]]$alleles <- c("W", "R", "S")
aTypes3[[1]]$probs <- c(0.8, 0.15, 0.05)

# replicate so each patch starts the same
AllAlleles <- list(aTypes1, aTypes1, aTypes3)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
rel1 <- basicRepeatedReleases(releaseStart = 50,
                                         releaseEnd = 60,
                                         releaseInterval = 5,
                                         genMos = c("HH"),
                                         numMos = c(25),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

rel2 <- basicRepeatedReleases(releaseStart = 100,
                                         releaseEnd = 110,
                                         releaseInterval = 5,
                                         genMos = c("RR"),
                                         numMos = c(25),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)




patchReleases[[1]]$maleReleases <- c(rel1, rel2)

# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365*3,
                           sampTime = 2,
                           AdPopEQ = c(100, 200, 300),
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 5, tLarva = 6, tPupa = 4, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 1,
         numReps = 5, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "mPlex_mLoci",
         verbose = FALSE)


####################
# Post Analysis
####################
# setup aggregation key
#  this example sets all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir, "0_AggKey.csv"), 
                  genotypes = list(NULL), collapse = c(FALSE))


# aggregate experiment by aggregation key
simAggregation(readDirectory = simDir, writeDirectory = aggDir, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)


# plot for example
plotmPlexSingle(directory = aggDir, whichPatches = NULL, nonZeroGen = FALSE)
plotmPlexMult(directory = aggDir,whichPatches = NULL, nonZeroGen = FALSE, lwd=0.35,alpha=0.75)
```

Looking at the aggkey, we can determine what genotypes appear when, and how they take-over the final populations.  

```{r}
aggKey <- read.csv(file = file.path(aggDir, "0_AggKey.csv"), header = TRUE)
aggKey
```

Looking at the first patch, we see releases of 1 very early in the males, which corresponds to the `HH` genotype given in the key. We then see releases of number 5 later on, corresponding to the `RR` releases we performed. We can see how these begin to migrate into the second patch. There is some transition as the green color, 4, rises and falls in the middle. This corresponds to the `HW` heterozygous individuals. Finally, the population is primarily taken over by 2, with some 5 mixed in. These correspond to the `HR` and `RR` individuals. Notice that the population drops significantly once this has happened. This is because of the fitness costs on `HH` and `RR` individuals. The effect of this can be seen in the repetitions plot, where the `HH` individuals died out in one simulation and the population remained `WW`.  
Notice, in the third patch which is not connected to the first two, the population begins mostly `WW`, with some `RR` and even less `SS` and heterozygous individuals. The population remains fairly constant, but begins to trend upwards as the fitness cost drives `RR` individuals out of the population. If we continued the simulation longer, eventually all of the `R` alleles would drop out of the population.

```{r, echo=FALSE}
####################
# Cleanup before next run
####################
unlink(x = outFolder, recursive = TRUE)
rm(list=ls())
```




### Large Genotype Example

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  hold = TRUE,
  fig.width = 7,
  fig.height = 7,
  eval = TRUE
)
```

In this example, we will explore a drive that targets 3 loci with variable effectiveness. We will put a fitness cost on the `HH` of the first locus, showing how each possible genotype needs to be specified in order for the fitness cost to be applied. Additionally, we'll run the simulation longer, and release different genotypes far enough apart that we can see the spread of each locus through the population. Finally, since the genotype diversity is so much more rich in this simulation, we will expand our analysis and plotting.  

  * `omega`: As these parameters are stored as hashmaps, each possible genotype that we want this cost applied to must be specified. As each locus has 10 possible genotypes, and there are 3 independent loci, that gives us 10^3 different genotypes. We will simplify this by not having any `S` alleles in the population.
  * `genOI_mLoci_Daisy()`: Since there are many genotypes, we can ask how each locus spreads within the population, and also how many individuals will have a homing allele at any locus.  
    * First, we will plot all of the genotypes in the simulation, just to express how difficult this becomes to interpret
    * Second, we will plot everything at the first locus, ignoring the other 2 loci
    * Third, we will plot everything at the second locus
    * Fourth, we will plot everything at the third locus
    * Fifth, we will plot individuals with an `H` allele at every locus
    * Sixth, we will plot individuals with an `H` allele at any locus

```{r, eval=TRUE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, paste0("aggDir", 1:6))
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 1-node network
sitesNumber <- 1
moveMat <- matrix(data = 1, nrow = sitesNumber, ncol = sitesNumber, byrow = TRUE)


####################
# Inheritance pattern
####################
# generate adult lifetime fitness cost
# Remember, each possible genotype must be specified.
# lociGenos are the alleles at each locus,
lociGenos <- c('HH','HR','HW','RR','RW','WW')

# complete genoes are all combinations at all 3 loci, 216 long for 3 genotypes 
#  and 6 different allele combinations
completeGenos <- expand.grid(lociGenos,lociGenos,lociGenos)

# find genotypes with HH at the third locus
#  We are ignoring all the rest of things, all combinations of 2 at each locus, etc.
#  Because I don't want to write all the code I need to do that.
locus1 <- grep(pattern = "HH", x = completeGenos$Var1, fixed = TRUE, useBytes = TRUE)

# combine loci names into a single list
completeGenos <- do.call(what = paste0, args = completeGenos)

# create named vector of fitness cost
#  since the default fitness is 1, we don't need to specify any genotypes that 
#  don't have a cost. Thus, only adding the ones with a fitness cost on the 
#  first locus.
omega <- setNames(object = rep.int(x = 0.6, times = length(locus1)),
                  nm = completeGenos[locus1])

# 3-locus CRISPR-like drive system
#  first locus is high homing, second is medium, third is poor
reproductionReference <- MakeReference_Multiplex_mLoci(H = c(0.95, 0.8, 0.4),
                                                       R = c(0.05, 0.2, 0.6),
                                                       S = c(0, 0, 0),
                                                       d = c(0, 0, 0),
                                                       omega = omega)


####################
# Setup Initial genotype ratios
####################
# 3 locus, start completely wild-type
aTypes <- vector(mode = "list", length = 3L) #3 locus
aTypes[[1]]$alleles <- c("W")
aTypes[[1]]$probs <- c(1L)
aTypes[[2]]$alleles <- c("W")
aTypes[[2]]$probs <- c(1L)
aTypes[[3]]$alleles <- c("W")
aTypes[[3]]$probs <- c(1L)
# replicate so each patch starts the same
AllAlleles <- list(aTypes)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
rel1 <- basicRepeatedReleases(releaseStart = 50,
                                         releaseEnd = 60,
                                         releaseInterval = 5,
                                         genMos = c("HHWWWW"),
                                         numMos = 25,
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

rel2 <- basicRepeatedReleases(releaseStart = 400,
                                         releaseEnd = 410,
                                         releaseInterval = 5,
                                         genMos = c("WWHHWW"),
                                         numMos = 25,
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

rel3 <- basicRepeatedReleases(releaseStart = 750,
                                         releaseEnd = 760,
                                         releaseInterval = 5,
                                         genMos = c("WWWWHH"),
                                         numMos = 25,
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

patchReleases[[1]]$maleReleases <- c(rel1, rel2, rel3)


# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365*6,
                           sampTime = 2,
                           AdPopEQ = 250,
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 5, tLarva = 6, tPupa = 4, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 1,
         numReps = 1, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "mPlex_mLoci",
         verbose = FALSE)


####################
# Aggregation Keys
####################
# Set all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir[1], "0_AggKey.csv"), 
                  genotypes = list(NULL, NULL, NULL),
                  collapse = c(FALSE, FALSE, FALSE))

# look at the first locus, ignore everything at the other two
genOI_mLoci_Daisy(outputFile = file.path(aggDir[2], "0_AggKey.csv"), 
                  genotypes = list(NULL, NULL, NULL),
                  collapse = c(FALSE, TRUE, TRUE))

# look at the second locus, ignore other two
genOI_mLoci_Daisy(outputFile = file.path(aggDir[3], "0_AggKey.csv"), 
                  genotypes = list(NULL, NULL, NULL),
                  collapse = c(TRUE, FALSE, TRUE))

# look at the third locus, ignore other two
genOI_mLoci_Daisy(outputFile = file.path(aggDir[4], "0_AggKey.csv"), 
                  genotypes = list(NULL, NULL, NULL),
                  collapse = c(TRUE, TRUE, FALSE))

# H allele at every locus, either 1 H or 2
genOI_mLoci_Daisy(outputFile = file.path(aggDir[5], "0_AggKey.csv"), 
                  genotypes = list(c("HH","HR","HW"), c("HH","HR","HW"), c("HH","HR","HW")),
                  collapse = c(TRUE, TRUE, TRUE))

# H allele at any locus
#  this will aggregate all of the other loci, so the "other" category will 
#  contain anything with an H allele at any locus
genOI_mLoci_Daisy(outputFile = file.path(aggDir[6], "0_AggKey.csv"), 
                  genotypes = list(c("RR","RW","WW"), c("RR","RW","WW"), c("RR","RW","WW")),
                  collapse = c(TRUE, TRUE, TRUE))


####################
# Aggregate
####################
# aggregate experiment by aggregation key
for(x in aggDir){
  simAggregation(readDirectory = simDir, writeDirectory = x, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)
}
```


```{r}
# all genotypes different
aggKey <- read.csv(file = file.path(aggDir[1], "0_AggKey.csv"), header = TRUE)
head(x = aggKey, n = 5)
tail(x = aggKey, n = 5)

plotmPlexSingle(directory = aggDir[1], whichPatches = NULL, nonZeroGen = FALSE)
```
For our first example, we didn't aggregate the genotypes at all and instead plotted all of them independently. Since there are 10 possible genotypes at each locus, and there are 3 loci, there are 10^3 (1000) distinct genotypes. Looking at the top and the bottom 5 genotypes in the aggregation key, we see that the genotypes are numbered 1 to 1000. The plot, as expected, is almost impossible to read.  

Instead, it makes more sense to look at genotypes combined by some metric. So, we'll start by looking at the behavior of each locus individually, ignoring what's happening at the other two.  
Looking at the first locus, we see that there are 10 unique genotypes, since there are 10 genotypes at each locus, and we're aggregating over the second and third loci. This was accomplished by setting the `collapse` argument in `genOI_mLoci_Daisy()`, so that the first locus is kept distinct, but the second and third are collapsed. 

```{r}
# First locus
aggKey <- read.csv(file = file.path(aggDir[2], "0_AggKey.csv"), header = TRUE)
head(x = aggKey, n = 5)
tail(x = aggKey, n = 5)

plotmPlexSingle(directory = aggDir[2], whichPatches = NULL, nonZeroGen = FALSE)
```

This plot is far easier to read. Now that we're only looking at 10 possible genotypes, it's possible to get a sense of what's going on. The pink link, number 10, corresponds to all individuals with `WW` in the first locus. We see a mix of genotype 4, `HW` at the first locus, blend into a mix of genotype 2, `HR` at the first locus, before genotype 5 begins to take over, with a small but significant amount of genotype 7, individuals with `RW` at the first locus. This makes sense, as there is a 40% fitness cost on individuals with `HH` at their first locus.  

Moving on, we can perform the same analysis at the second locus.

```{r}
# second locus
aggKey <- read.csv(file = file.path(aggDir[3], "0_AggKey.csv"), header = TRUE)
head(x = aggKey, n = 5)
tail(x = aggKey, n = 5)

plotmPlexSingle(directory = aggDir[3], whichPatches = NULL, nonZeroGen = FALSE)
```

This time, notice how the first 400 days are completely genotype 10, `WW`, at the second locus. This is because no releases at the second locus were performed until day 400, as each locus is independent. After the initial releases, we see a quick but short uptick of genotype 4, `HW` heterozygotes at locus two, which is quickly replaced mostly be genotype 1, `HH` individuals, with a small amount of genotype 2, `HR` heterozygotes. This happens because there is no fitness cost on anything at the second locus, so the `H` allele drives to completion, but it drives less effectively than locus one, 80% effective compared to 95%, thus creating a higher proportion of `R` alleles in the process.  

Finally, we can perform the same analysis on the third locus. Again, this locus has no fitness cost, but it is the least effective of the three, driving only at a 60% rate.

```{r}
# third locus
aggKey <- read.csv(file = file.path(aggDir[4], "0_AggKey.csv"), header = TRUE)
head(x = aggKey, n = 5)
tail(x = aggKey, n = 5)

plotmPlexSingle(directory = aggDir[4], whichPatches = NULL, nonZeroGen = FALSE)
```

Prior to the releases at 750 days, we see that genotype 10, `WW` individuals at locus three, are dominant, but also a dip in the population. This comes from the fitness cost associated with the first locus, which reduces the population as it spreads, until enough of the population is resistant that the size begins to bounce back. We don't see this when analyzing locus two because releases were performed at nearly the same time, thus masking this effect with the change in genotypes. Shortly after the release, we see an increase in genotype 4, `HW` heterozygotes, as the `H` allele begins to drive through the population. However, since the drive efficacy is so low, the final population is a mix of genotypes 2, 1, and 5, corresponding to genotypes `HR`, `HH`, and `RR` at locus three.  

While it is interesting to view each locus independently, there are other metrics that are more valuable. If this drive carried different transgenes with it, then having the drive at every locus is the only way to ensure that an individual possesses all of the transgenes. This can be analyzed by specifying all of the genotypes of interest at each locus, using the `genotypes` option in `genOI_mLoci_Daisy()`. This way, our data is aggregated into two groups:  

  * 1: Individuals with any of our desired genotypes at each locus  
  * other: Individuals that do not have our desired genotypes at all loci  
  
This will divide the population into individuals with an `H` allele at all loci, and individuals that do not have an `H` allele at all loci.

```{r}
# H at every locus
aggKey <- read.csv(file = file.path(aggDir[5], "0_AggKey.csv"), header = TRUE)
aggKey

plotmPlexSingle(directory = aggDir[5], whichPatches = NULL, nonZeroGen = FALSE)
```

Looking at the analysis, we see that there is only a very small window when part of the population has an `H` allele at all loci. We can also see the population drop early on, from when the `HH` genotype was prevalent at the first locus. It is probably the fitness cost from the first locus that prevents the population from containing `H` alleles at all loci.  

Alternatively, the point of multiplexing is that the loci can act as redundancies. In this method, we would put the same transgene at each locus, and then hope that individuals contain an `H` allele at any locus. This might be useful if the population is slightly heterogeneous at each locus, and thus our transgene can't spread to completion at any single locus. By having multiple loci, it's highly likely that an individual will contain the transgene at any one locus, even if not at all of them. Our simulation matches this scenario, as there is a high fitness cost on the first locus, driving the `H` allele out of the population there, and the drive isn't as effective at loci two and three, meaning that it won't spread to completion at either of those loci alone.

```{r}
# H at any locus
aggKey <- read.csv(file = file.path(aggDir[6], "0_AggKey.csv"), header = TRUE)
aggKey

plotmPlexSingle(directory = aggDir[6], whichPatches = NULL, nonZeroGen = FALSE)
```

However, by targeting three loci with variable abilities and costs, we successfully drive our transgene into the population at nearly a 100% rate. Notice, even at the end there are still some individuals that do not contain the transgene at any locus. The resistant alleles created won't die out, because there is no cost on them in our simulation, but the population is continually mixing and the loci recombine at each generation, hence why the "failed" individuals appear and disappear. This would be reduced with some cost on the `R` allele, or if the first locus had a smaller cost (remember the `H` allele effectively disappears at that locus, so we really only have 2 effective loci here), or if the drives at the second and third loci were more effective. 


```{r, echo=FALSE}
####################
# Cleanup before next run
####################
unlink(x = outFolder, recursive = TRUE)
rm(list=ls())
```

