---
title: "mPlex Multiple Loci Run Example"
#output: rmarkdown::pdf_document
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{mPlex-mLoc}
  %\VignetteEncoding{UTF-8}
---

```{css, echo = FALSE}
pre {
  white-space: pre !important;
  overflow-y: scroll !important;
  max-height: 25vh !important;
}

# reference
#  https://stackoverflow.com/questions/41135085/how-to-make-vertical-scrollbar-appear-in-rmarkdown-code-chunks-html-view
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  hold = TRUE,
  fig.width = 7,
  fig.height = 10.5,
  eval = TRUE
)
```


## mPlex - Multiple Locus Inheritance Simulation

This vignette goes through setting up and running a *mPlex* simulation using the 
`mPlex_mLoci` inheritance pattern. This inheritance pattern demonstrates a homing drive 
that targets multiple independent loci. Here, we will explore 3 examples: a basic simulation, 
with one locus, and no extra parameters. Next, the same population 
setup but with a fitness cost on one of the genotypes. Finally, a larger simulation 
with multiple genotypes to demonstrate more complicated plotting/analysis procedures.


### Basic Example

The first example explores homing into one locus with no extra parameters. This 
is equivalent to the basic homing drive from *MGDrivE*. We will simulate 3 
populations, two with migration and one independent so that that the file structure 
becomes more obvious. 

#### Full Code

For reference, here is the full code for our example. It will be explained piece-by-piece below.

```{r, eval=FALSE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, "aggDir")
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 3-node network with 2% per day migration rate
#  Remember, rows need to sum to 1.
sitesNumber <- 3
moveMat <- matrix(data = c(0.98, 0.02, 0,
                           0.02, 0.98, 0,
                           0, 0, 1), nrow = sitesNumber, ncol = sitesNumber, byrow = TRUE)


####################
# Inheritance pattern
####################
# 1-locus CRISPR-like drive system, with no extra genotype-specific costs
#  97% homing rate, 3% resistance rate, no backgorund mutation
reproductionReference <- MakeReference_Multiplex_mLoci(H = c(0.97),
                                                       R = c(0.03),
                                                       S = c(0),
                                                       d = c(0))


####################
# Setup Initial genotype ratios
####################
# 1 locus, start completely wild-type
alleloTypes <- vector(mode = "list", length = 1L) #1 locus
alleloTypes[[1]]$alleles <- c("W")
alleloTypes[[1]]$probs <- c(1)

# replicate so each patch starts the same
AllAlleles <- replicate(n = sitesNumber, expr = alleloTypes, simplify = FALSE)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
patchReleases[[1]]$maleReleases <- basicRepeatedReleases(releaseStart = 50,
                                         releaseEnd = 60,
                                         releaseInterval = 5,
                                         genMos = c("HH"),
                                         numMos = c(25),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365,
                           sampTime = 2,
                           AdPopEQ = 100,
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 5, tLarva = 6, tPupa = 4, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 1,
         numReps = 5, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "mPlex_mLoci",
         verbose = FALSE)


####################
# Post Analysis
####################
# setup aggregation key
#  this example sets all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir, "0_AggKey.csv"), 
                  genotypes = list(NULL), collapse = c(FALSE))


# aggregate experiment by aggregation key
simAggregation(readDirectory = simDir, writeDirectory = aggDir, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)


# plot for example
plotmPlexSingle(directory = aggDir, whichPatches = NULL, nonZeroGen = FALSE)
plotmPlexMult(directory = aggDir,whichPatches = NULL, nonZeroGen = FALSE, lwd=0.35,alpha=0.75)
```


#### Load Libraries

```{r}
####################
# Load libraries
####################
library(mPlexCpp)

```

Step one, load *mPlex*. All of the analysis and basic plotting functions are included in the package. 

#### Setup Folder Directory

```{r}
####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, "aggDir")
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

```

Here, we setup the folder for simulation data. Since this is a local folder, it doesn't exist, and needs to be created. If you already have a folder prepared, make sure it is empty. *mPlex* does not give a warning if there are other things in the folder (to prevent overwriting of data), but will run fine if the folder is not empty.

#### Landscape

For this simulation, we setup a simple landscape to demonstrate mixing and independence between populations. The first 2 populations are connected by a 2% per day migration rate, while the third population is independent of the other two. All populations run indepdently in the simulation, and only exchange adults via this migration matrix. We use the same matrix for both male and female adult migration in our simulation, but that doesn't need to be so.

```{r}
####################
# Landscape
####################
# a 3-node network with 2% per day migration rate
#  Remember, rows need to sum to 1.
sitesNumber <- 3
moveMat <- matrix(data = c(0.98, 0.02, 0,
                           0.02, 0.98, 0,
                           0, 0, 1), nrow = sitesNumber, ncol = sitesNumber, byrow = TRUE)

moveMat
```


#### Inheritance Pattern

*mPlex* currently supports 4 inheritance patterns. The one exemplified here is a CRISPR-style homing into independent loci. For this example, we show only 1 locus. The alleles correspond to:  

  * `W`: Wild-type allele
  * `H`: Homing allele
  * `R`: Resistant allele 1
  * `S`: Resistant allele 2

```{r}
####################
# Inheritance pattern
####################
# 1-locus CRISPR-like drive system, with no extra genotype-specific costs
#  97% homing rate, 3% resistance rate, no backgorund mutation
reproductionReference <- MakeReference_Multiplex_mLoci(H = c(0.97),
                                                       R = c(0.03),
                                                       S = c(0),
                                                       d = c(0))
```

While we use the default parameters, there are several fitness costs that can be applied. Every cost is applied in a genotype-specific manner. The optional fitness costs are:  

  * $\eta$: Male mating fitness against each female  
  * $\phi$: Sex-ratio at emergence  
  * $\omega$: Multiplicative modifier of adult mortality (males and females)  
  * $\xi_F$: Female pupatory success (applies after $\phi$)  
  * $\xi_M$: Male pupatory success (applies after $\phi$)  
  * $s$: Fractional increase/decrease in fertility  
  
These costs are implemented as hash tables, searched by genotype. Therefore, all genotypes that you wish to provide a cost for must be specified (this gets extremely complicated with larger genotype space), and any genotypes that are misspelled are fine, nothing will crash, but they will not be applied during the simulation.
  

#### Initial Genotype Ratios

*mPlex* requires the initial allele ratios to be specified. From this, the populations are setup at their age-structed, genotypic equilibriums. These can be specified differently for each patch, or provided as a single, length 1 list, which will be internally replicated so that all patches begin at the same genotype equilibrium. These genotypes do need to match the inheritance pattern supplied above. This is checked in the run script.


```{r}
####################
# Setup Initial genotype ratios
####################
# 1 locus, start completely wild-type
alleloTypes <- vector(mode = "list", length = 1L) #1 locus
alleloTypes[[1]]$alleles <- c("W")
alleloTypes[[1]]$probs <- c(1)

# replicate so each patch starts the same
AllAlleles <- replicate(n = sitesNumber, expr = alleloTypes, simplify = FALSE)
```


#### Releases and Batch Migration

*mPlex* uses a list specifying the releases by male, female, or egg, their genotypes, and the release schedule. The initial list is `NULL`, and only if there are releases to be performed is anything added. 


```{r}
####################
# Setup releases and batch migration
####################
# create release List
#  mPlex pulls things out by name
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
patchReleases[[1]]$maleReleases <- basicRepeatedReleases(releaseStart = 50,
                                         releaseEnd = 60,
                                         releaseInterval = 5,
                                         genMos = c("HH"),
                                         numMos = c(25),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)
```

Here, we perform `r length(patchReleases[[1]]$maleReleases)` releases of male adults. Each release contains 25 individuals, of genotype `HH`, equally spaced from 16 to 24 days old. 

The final release can be seen below:

```{r}
# look at male release structure
patchReleases[[1]]$maleReleases
```

Additionally, there is the possibility of large-group movement facilitated by humans (using *Aedes* for example, this could be boats or water containers in truck beds, etc.). *mPlex* handles this through `basicBatchMigration()`. For simplicity, we are ignoring this possibility (by setting the probability of it to zero).

```{r}
# batch migration is disabled by setting the probability to 0
migrationBatch <- basicBatchMigration(batchProbs=0, numPatches=sitesNumber)
```


#### Simulation Parameters

Next, there are several parameters that need to be set for a simulation. The run time, number of populations, and adult population equilibrium are crucial. Each of these must be specified for the aquatic populations to be created. The `AdPopEQ` can be a single number, and all populations then are the same size, or a vector, specifying each population individually. Additionally, the `sampTime` parameter controls how often output is written. 

```{r}
####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365,
                           sampTime = 1,
                           AdPopEQ = 100,
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 5, tLarva = 6, tPupa = 4, muAd = 0.09)
```

The biological parameters were chosen for _Aedes aegypti_ in our original simulations. These parameters represent:  

  * `beta`: Daily number of eggs laid per female mosquito
  * `tEgg`: Number of days spent in the egg stage
  * `tLarva`: Number of days spent in the larval stage
  * `tPupa`: Number of days spent in the pupa stage
  * `dayGrowthRate`: Population growth per generation  
  * `muAd`: Daily death rate for adult mosquitoes


#### Run Simulation

`mPlex` is an individual-based model, and thus only runst stochastically. There are several options to parameterize it:  

  * `seed`: Seed to set mersenne twister
  * `numThreads`: Internal multithreading
  * `numReps`: Number of repetitions to perform
  * `networkParameters`: Parameters setup above, includes life-cycle parameters
  * `reproductionReference`: Reference specifying everything necessary to calculate genotypes for each generation
  * `initAlleles`: List specifying the inital allele distribution
  * `patchReleases`: List specifying releases for each population
  * `migrationMale/Female`: Matrices specifying sex-specific adult daily movement
  * `migrationBatch`: List specifying adult batch migration possibilities
  * `outputDirectory`: Directory two write raw output. All repetitions are written to the same place
  * `reproductionType`: Flag specifying which inheritance pattern is desired. This is used to check against `reproductionReference`, `initAlleles`, and `patchReleases`
  * `verbose`: Be chatty? Default is true, but is turned off for vignette building.

```{r}
####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 1,
         numReps = 5, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "mPlex_mLoci",
         verbose = FALSE)

# list folders to show that they have been created
list.files(path = outFolder)
list.files(path = simDir)
```


#### Post Processing

*mPlex* outputs 2 *.csv files per patch, so our example simulation has 6 files per repetition. Each file is labeled `{F|M}_Run_XXX_Patch_XXX.csv`, denoting adult male/female output, the patch, and the repetition. These files contain the entire adult population, written at each time point specified by `sampTime`. We can look at the raw output, which differs slightly for males and females.

```{r}
# read in male and female files
fDataFrame <- read.csv(file = list.files(path = simDir, full.names = TRUE)[1], 
                       header = TRUE)
mDataFrame <- read.csv(file = tail(x = list.files(path = simDir, full.names = TRUE), 
                                   n = 1), 
                       header = TRUE)

# look at male file header
colnames(mDataFrame)
```

The header in male files (`M_Run_XXX_Patch_XXX.csv`) is shown above. It always contains the Time, Age, and Genotype for every individual in a population. Because genotypes change with inheritance pattern and with the size of each inheritance type, there's not easy way to specify each genotype. Thus, they are summarized as simply `Genotype`. Time zero indicates the initial conditions of the simulation.  

The female files (`F_Run_XXX_Patch_XXX.csv`) are only a little more complicated. Because females only mate once in their lives, their mate choice is kept with their genotype. So, female files have one more column than male files. 

```{r}
# look at female file header
colnames(fDataFrame)
```

We can look at the first few rows of the female file (male files are the same, but minus mates, so we will only look at females.)

```{r}
head(x = fDataFrame, n = 5)
```

Notice, at the beginning, none of the females are mated. This is fixed after 1 day. Skipping the rest of the first day (about 50 individuals, since the equilibrium population is 100 and half of those are female), we can see what it looks like after mating is performed.

```{r}
fDataFrame[50:55,]
```

This output is hard to use directly, as it is a list of every individual in the population. It is easier if we counted how many of each genotype and stored the data that way. This is done in two steps. The first step is to specify what genotypes are of interest. In this example, there are only 10 possible genotypes, so it's not difficult to view them all. However, when the genotypes get more complicated, this becomes too difficult. 

```{r}
####################
# Post Analysis
####################
# setup aggregation key
#  this example sets all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir, "0_AggKey.csv"), 
                  genotypes = list(NULL), collapse = c(FALSE))

list.files(path = aggDir)
```

*mPlex* provides 2 functions to generate aggregation keys, `genOI_mLoci_Daisy()` and `genOI_oLocus()`. These functions output a *.csv with the key describing genotypes of interest, and how they are combined when the data is aggregated using `simAggregation()`.  

  * `genotypes` is a list, the same length as the number of loci, specifying genotypes of interest at each locus. The default is that all genotypes are of interest.
  * `collapse` is a boolean vector, same length as `genotypes`, of whether to keep the genotypes of interest separate or to combine the count. i.e., if you have 3 genotypes of interest, do you want all three kept separate, or do you want the total of all three of those genotypes? The default is to keep them all separate.
  
The file name provided, "0_AggKey.csv", is numbered so it is easier for the user to find it (it is always the first file in a folder this way), but must contain "AggKey", as this is how `simAggregation()` finds the file.  

The aggregation key for 1 locus, keeping all genotypes of interest distinct, can be seen below.
```{r}
aggKey <- read.csv(file = file.path(aggDir, "0_AggKey.csv"), header = TRUE)
aggKey
```

Next, the files are aggregated with `simAggregation()`. 

```{r}
# aggregate experiment by aggregation key
simAggregation(readDirectory = simDir, writeDirectory = aggDir, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)

list.files(path = aggDir)
```

Because `simAggregation()` takes a key for aggregation, the user can generate multiple keys in different folders, and perform different aggregations of the data. The data is now stored in a condensed format, with one row for each time-step, and columns for every aggregation number in the key generated above. The male/female files are identical in structure now.

```{r}
# read in male and female files
fMat <- as.matrix(read.csv(file = list.files(path = aggDir, full.names = TRUE)[2], 
                       header = TRUE, check.names = FALSE))
mMat <- as.matrix(read.csv(file = tail(x = list.files(path = aggDir, full.names = TRUE), 
                                   n = 1), 
                       header = TRUE, check.names = FALSE))

# look at male and female file headers
colnames(mMat)
colnames(fMat)
```

Looking at the first few rows of each, we see that they have been reduced to counts over each genotype of interest, with an "Other" column holding all individuals that did not fit our key. Here, since we specified all genotypes, there are no "others", but this will occur in more complicated scenarios.

```{r}
head(x = mMat, n = 3)
head(x = fMat, n = 3)
```


#### Plotting

*mPlex* comes with two built-in plot functions, `plotmPlexSingle()` and `plotmPlexMult()`.  
`plotmPlexSingle()` takes the name of one repetition folder, and plots all of the patches in it for both males and females. 

```{r}
# plot the first repetition
plotmPlexSingle(directory = aggDir, whichPatches = NULL, nonZeroGen = FALSE)
```

The left Y-axis is population size, the right Y-axis is patch number, and the X-axis is time. We can see the releases in the first patch, equal for males and females, and follow their migration down the plots from patch 1 to patch 2, with patch 3 remaining completely independent. The total population remains around 250 individuals for males and females, which gives the expected equilibrium value of 500.  The legend shows the aggregation key generated above. This is done because more comlicated experiments will have genotypes too long to display well, or our genotypes of interest will be a combination of multiple genotypes, which will be hard to put in a legend.  
We can also plot all of our repetitions using `plotmPlexMult()`.  

```{r}
# plot all 5 repetitions together
plotmPlexMult(directory = aggDir,whichPatches = NULL, nonZeroGen = FALSE, lwd=0.35,alpha=0.75)
```

`plotmPlexMult()` takes the name of the main directory, and finds all of the repetitions inside of it. It then plots males and females by patch, the same as `plotmPlexSingle()`, but overlays a trace of every repetition for each patch.


```{r, echo=FALSE}
####################
# Cleanup before next run
####################
unlink(x = outFolder, recursive = TRUE)
rm(list=ls())
```




### Small Genotype Example

In this second example, we will provide fitness costs for some of the genotypes, change the initial conditions of the patches, and modify the releases.  

  * `omega`: Adult mortality. We provide a cost so that two of the genotypes are less fit than the wild-type
    * `HH`: Homozygous homing individuals are only 50% as fit as wild-type
    * `RR`: Homozygous resistant 1 individuals are 90% as fit as wild-type
  * `aTypes3`: The third population begins as a mix of `W`, `R`, and `S` alleles, in the provided proportions
  * `rel2`: A second release is performed in the first patch, integrating `RR` individuals at time = 100
  * `AdPopEQ`: Patches are now different sizes, with the adult populations set as 100, 200, and 300
  * `sampTime`: We sample every other day by setting the `sampTime` parameter as 2

```{r, eval=TRUE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, "aggDir")
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 3-node network with 2% per day migration rate
#  Remember, rows need to sum to 1.
sitesNumber <- 3
moveMat <- matrix(data = c(0.98, 0.02, 0,
                           0.02, 0.98, 0,
                           0, 0, 1), nrow = sitesNumber, ncol = sitesNumber, byrow = TRUE)


####################
# Inheritance pattern
####################
# 1-locus CRISPR-like drive system
#  97% homing rate, 3% resistance rate, no backgorund mutation
reproductionReference <- MakeReference_Multiplex_mLoci(H = c(0.97),
                                                       R = c(0.03),
                                                       S = c(0),
                                                       d = c(0), omega = c("HH"=0.5, "RR" = 0.9))


####################
# Setup Initial genotype ratios
####################
# 1 locus, start completely wild-type in patches 1 and 2
#  start with a mixture in patch 3
aTypes1 <- vector(mode = "list", length = 1L) #1 locus
aTypes1[[1]]$alleles <- c("W")
aTypes1[[1]]$probs <- c(1L)
aTypes3 <- vector(mode = "list", length = 1L) #1 locus
aTypes3[[1]]$alleles <- c("W", "R", "S")
aTypes3[[1]]$probs <- c(0.8, 0.15, 0.05)

# replicate so each patch starts the same
AllAlleles <- list(aTypes1, aTypes1, aTypes3)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
rel1 <- basicRepeatedReleases(releaseStart = 50,
                                         releaseEnd = 60,
                                         releaseInterval = 5,
                                         genMos = c("HH"),
                                         numMos = c(25),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

rel2 <- basicRepeatedReleases(releaseStart = 100,
                                         releaseEnd = 110,
                                         releaseInterval = 5,
                                         genMos = c("RR"),
                                         numMos = c(25),
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)




patchReleases[[1]]$maleReleases <- c(rel1, rel2)

# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365*3,
                           sampTime = 2,
                           AdPopEQ = c(100, 200, 300),
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 5, tLarva = 6, tPupa = 4, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 1,
         numReps = 5, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "mPlex_mLoci",
         verbose = FALSE)


####################
# Post Analysis
####################
# setup aggregation key
#  this example sets all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir, "0_AggKey.csv"), 
                  genotypes = list(NULL), collapse = c(FALSE))


# aggregate experiment by aggregation key
simAggregation(readDirectory = simDir, writeDirectory = aggDir, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)


# plot for example
plotmPlexSingle(directory = aggDir, whichPatches = NULL, nonZeroGen = FALSE)
plotmPlexMult(directory = aggDir,whichPatches = NULL, nonZeroGen = FALSE, lwd=0.35,alpha=0.75)
```

Looking at the aggkey, we can determine what genotypes appear when, and how they take-over the final populations.  

```{r}
aggKey <- read.csv(file = file.path(aggDir, "0_AggKey.csv"), header = TRUE)
aggKey
```

Looking at the first patch, we see releases of 1 very early in the males, which corresponds to the `HH` genotype given in the key. We then see releases of number 5 later on, corresponding to the `RR` releases we performed. We can see how these begin to migrate into the second patch. There is some transition as the green color, 4, rises and falls in the middle. This corresponds to the `HW` heterozygous individuals. Finally, the population is primarily taken over by 2, with some 5 mixed in. These correspond to the `HR` and `RR` individuals. Notice that the population drops significantly once this has happened. This is because of the fitness costs on `HH` and `RR` individuals. The effect of this can be seen in the repetitions plot, where the `HH` individuals died out in one simulation and the population remained `WW`.  
Notice, in the third patch which is not connected to the first two, the population begins mostly `WW`, with some `RR` and even less `SS` and heterozygous individuals. The population remains fairly constant, but begins to trend upwards as the fitness cost drives `RR` individuals out of the population. If we continued the simulation longer, eventually all of the `R` alleles would drop out of the population.

```{r, echo=FALSE}
####################
# Cleanup before next run
####################
unlink(x = outFolder, recursive = TRUE)
rm(list=ls())
```




### Large Genotype Example

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  hold = TRUE,
  fig.width = 7,
  fig.height = 7,
  eval = TRUE
)
```

In this example, we will explore a drive that targets 3 loci with variable effectiveness. We will put a fitness cost on the `HH` of the first locus, showing how each possible genotype needs to be specified in order for the fitness cost to be applied. Additionally, we'll run the simulation longer, and release different genotypes far enough apart that we can see the spread of each locus through the population. Finally, since the genotype diversity is so much more rich in this simulation, we will expand our analysis and plotting.  

  * `omega`: As these parameters are stored as hashmaps, each possible genotype that we want this cost applied to must be specified. As each locus has 10 possible genotypes, and there are 3 independent loci, that gives us 10^3 different genotypes. We will simplify this by not having any `S` alleles in the population.
  * `genOI_mLoci_Daisy()`: Since there are many genotypes, we can ask how each locus spreads within the population, and also how many individuals will have a homing allele at any locus.  
    * First, we will plot all of the genotypes in the simulation, just to express how difficult this becomes to interpret
    * Second, we will plot everything at the first locus, ignoring the other 2 loci
    * Third, we will plot everything at the second locus
    * Fourth, we will plot everything at the third locus
    * Fifth, we will plot individuals with an `H` allele at every locus
    * Sixth, we will plot individuals with an `H` allele at any locus

```{r, eval=TRUE}
####################
# Load libraries
####################
library(mPlexCpp)

####################
# Output Folder
####################
outFolder <- "mPlex"

simDir <- file.path(outFolder, "simDir")
aggDir <- file.path(outFolder, paste0("aggDir", 1:6))
for(i in c(outFolder, simDir, aggDir)){ dir.create(i) }

                        
####################
# Landscape
####################
# a 1-node network
sitesNumber <- 1
moveMat <- matrix(data = 1, nrow = sitesNumber, ncol = sitesNumber, byrow = TRUE)


####################
# Inheritance pattern
####################
# generate adult lifetime fitness cost
# Remember, each possible genotype must be specified.
# lociGenos are the alleles at each locus,
lociGenos <- c('HH','HR','HW','RR','RW','WW')

# complete genoes are all combinations at all 3 loci, 216 long for 3 genotypes 
#  and 6 different allele combinations
completeGenos <- expand.grid(lociGenos,lociGenos,lociGenos)

# find genotypes with HH at the third locus
#  We are ignoring all the rest of things, all combinations of 2 at each locus, etc.
#  Because I don't want to write all the code I need to do that.
locus1 <- grep(pattern = "HH", x = completeGenos$Var1, fixed = TRUE, useBytes = TRUE)

# combine loci names into a single list
completeGenos <- do.call(what = paste0, args = completeGenos)

# create named vector of fitness cost
#  since the default fitness is 1, we don't need to specify any genotypes that 
#  don't have a cost. Thus, only adding the ones with a fitness cost on the 
#  first locus.
omega <- setNames(object = rep.int(x = 0.6, times = length(locus1)),
                  nm = completeGenos[locus1])

# 3-locus CRISPR-like drive system
#  first locus is high homing, second is medium, third is poor
reproductionReference <- MakeReference_Multiplex_mLoci(H = c(0.95, 0.8, 0.4),
                                                       R = c(0.05, 0.2, 0.6),
                                                       S = c(0, 0, 0),
                                                       d = c(0, 0, 0),
                                                       omega = omega)


####################
# Setup Initial genotype ratios
####################
# 3 locus, start completely wild-type
aTypes <- vector(mode = "list", length = 3L) #3 locus
aTypes[[1]]$alleles <- c("W")
aTypes[[1]]$probs <- c(1L)
aTypes[[2]]$alleles <- c("W")
aTypes[[2]]$probs <- c(1L)
aTypes[[3]]$alleles <- c("W")
aTypes[[3]]$probs <- c(1L)
# replicate so each patch starts the same
AllAlleles <- list(aTypes)


####################
# Setup releases and batch migration
####################
# create Release List
patchReleases = replicate(n = sitesNumber,
                          expr = list(maleReleases = NULL,
                                      femaleReleases = NULL,
                                      eggReleases = NULL),
                          simplify = FALSE)

# Create release object to pass to patches
rel1 <- basicRepeatedReleases(releaseStart = 50,
                                         releaseEnd = 60,
                                         releaseInterval = 5,
                                         genMos = c("HHWWWW"),
                                         numMos = 25,
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

rel2 <- basicRepeatedReleases(releaseStart = 400,
                                         releaseEnd = 410,
                                         releaseInterval = 5,
                                         genMos = c("WWHHWW"),
                                         numMos = 25,
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

rel3 <- basicRepeatedReleases(releaseStart = 750,
                                         releaseEnd = 760,
                                         releaseInterval = 5,
                                         genMos = c("WWWWHH"),
                                         numMos = 25,
                                         minAge = 16,
                                         maxAge = 24,
                                         ageDist = rep(x = 1, times = 24-16+1)/9)

patchReleases[[1]]$maleReleases <- c(rel1, rel2, rel3)


# default migration rate is 0, so no actual batch migration
migrationBatch <- basicBatchMigration(numPatches = sitesNumber)


####################
# Parameter Setup
####################
netPar = NetworkParameters(nPatch = sitesNumber,
                           simTime = 365*6,
                           sampTime = 2,
                           AdPopEQ = 250,
                           runID = 1L,
                           dayGrowthRate = 1.175,
                           beta = 20, tEgg = 5, tLarva = 6, tPupa = 4, muAd = 0.09)

####################
# Run Simulation
####################
runMPlex(seed = 10,
         numThreads = 1,
         numReps = 1, 
         networkParameters = netPar,
         reproductionReference = reproductionReference,
         initAlleles = AllAlleles,
         patchReleases = patchReleases,
         migrationMale = moveMat,
         migrationFemale = moveMat,
         migrationBatch = migrationBatch,
         outputDirectory = simDir,
         reproductionType = "mPlex_mLoci",
         verbose = FALSE)


####################
# Aggregation Keys
####################
# Set all genotypes as different
genOI_mLoci_Daisy(outputFile = file.path(aggDir[1], "0_AggKey.csv"), 
                  genotypes = list(NULL, NULL, NULL),
                  collapse = c(FALSE, FALSE, FALSE))

# look at the first locus, ignore everything at the other two
genOI_mLoci_Daisy(outputFile = file.path(aggDir[2], "0_AggKey.csv"), 
                  genotypes = list(NULL, NULL, NULL),
                  collapse = c(FALSE, TRUE, TRUE))

# look at the second locus, ignore other two
genOI_mLoci_Daisy(outputFile = file.path(aggDir[3], "0_AggKey.csv"), 
                  genotypes = list(NULL, NULL, NULL),
                  collapse = c(TRUE, FALSE, TRUE))

# look at the third locus, ignore other two
genOI_mLoci_Daisy(outputFile = file.path(aggDir[4], "0_AggKey.csv"), 
                  genotypes = list(NULL, NULL, NULL),
                  collapse = c(TRUE, TRUE, FALSE))

# H allele at every locus, either 1 H or 2
genOI_mLoci_Daisy(outputFile = file.path(aggDir[5], "0_AggKey.csv"), 
                  genotypes = list(c("HH","HR","HW"), c("HH","HR","HW"), c("HH","HR","HW")),
                  collapse = c(TRUE, TRUE, TRUE))

# H allele at any locus
#  this will aggregate all of the other loci, so the "other" category will 
#  contain anything with an H allele at any locus
genOI_mLoci_Daisy(outputFile = file.path(aggDir[6], "0_AggKey.csv"), 
                  genotypes = list(c("RR","RW","WW"), c("RR","RW","WW"), c("RR","RW","WW")),
                  collapse = c(TRUE, TRUE, TRUE))


####################
# Aggregate
####################
# aggregate experiment by aggregation key
for(x in aggDir){
  simAggregation(readDirectory = simDir, writeDirectory = x, 
               simTime = netPar$simTime, sampTime = netPar$sampTime)
}
```


```{r}
# all genotypes different
aggKey <- read.csv(file = file.path(aggDir[1], "0_AggKey.csv"), header = TRUE)
head(x = aggKey, n = 5)
tail(x = aggKey, n = 5)

plotmPlexSingle(directory = aggDir[1], whichPatches = NULL, nonZeroGen = FALSE)
```
For our first example, we didn't aggregate the genotypes at all and instead plotted all of them independently. Since there are 10 possible genotypes at each locus, and there are 3 loci, there are 10^3 (1000) distinct genotypes. Looking at the top and the bottom 5 genotypes in the aggregation key, we see that the genotypes are numbered 1 to 1000. The plot, as expected, is almost impossible to read.  

Instead, it makes more sense to look at genotypes combined by some metric. So, we'll start by looking at the behavior of each locus individually, ignoring what's happening at the other two.  
Looking at the first locus, we see that there are 10 unique genotypes, since there are 10 genotypes at each locus, and we're aggregating over the second and third loci. This was accomplished by setting the `collapse` argument in `genOI_mLoci_Daisy()`, so that the first locus is kept distinct, but the second and third are collapsed. 

```{r}
# First locus
aggKey <- read.csv(file = file.path(aggDir[2], "0_AggKey.csv"), header = TRUE)
head(x = aggKey, n = 5)
tail(x = aggKey, n = 5)

plotmPlexSingle(directory = aggDir[2], whichPatches = NULL, nonZeroGen = FALSE)
```

This plot is far easier to read. Now that we're only looking at 10 possible genotypes, it's possible to get a sense of what's going on. The pink link, number 10, corresponds to all individuals with `WW` in the first locus. We see a mix of genotype 4, `HW` at the first locus, blend into a mix of genotype 2, `HR` at the first locus, before genotype 5 begins to take over, with a small but significant amount of genotype 7, individuals with `RW` at the first locus. This makes sense, as there is a 40% fitness cost on individuals with `HH` at their first locus.  

Moving on, we can perform the same analysis at the second locus.

```{r}
# second locus
aggKey <- read.csv(file = file.path(aggDir[3], "0_AggKey.csv"), header = TRUE)
head(x = aggKey, n = 5)
tail(x = aggKey, n = 5)

plotmPlexSingle(directory = aggDir[3], whichPatches = NULL, nonZeroGen = FALSE)
```

This time, notice how the first 400 days are completely genotype 10, `WW`, at the second locus. This is because no releases at the second locus were performed until day 400, as each locus is independent. After the initial releases, we see a quick but short uptick of genotype 4, `HW` heterozygotes at locus two, which is quickly replaced mostly be genotype 1, `HH` individuals, with a small amount of genotype 2, `HR` heterozygotes. This happens because there is no fitness cost on anything at the second locus, so the `H` allele drives to completion, but it drives less effectively than locus one, 80% effective compared to 95%, thus creating a higher proportion of `R` alleles in the process.  

Finally, we can perform the same analysis on the third locus. Again, this locus has no fitness cost, but it is the least effective of the three, driving only at a 60% rate.

```{r}
# third locus
aggKey <- read.csv(file = file.path(aggDir[4], "0_AggKey.csv"), header = TRUE)
head(x = aggKey, n = 5)
tail(x = aggKey, n = 5)

plotmPlexSingle(directory = aggDir[4], whichPatches = NULL, nonZeroGen = FALSE)
```

Prior to the releases at 750 days, we see that genotype 10, `WW` individuals at locus three, are dominant, but also a dip in the population. This comes from the fitness cost associated with the first locus, which reduces the population as it spreads, until enough of the population is resistant that the size begins to bounce back. We don't see this when analyzing locus two because releases were performed at nearly the same time, thus masking this effect with the change in genotypes. Shortly after the release, we see an increase in genotype 4, `HW` heterozygotes, as the `H` allele begins to drive through the population. However, since the drive efficacy is so low, the final population is a mix of genotypes 2, 1, and 5, corresponding to genotypes `HR`, `HH`, and `RR` at locus three.  

While it is interesting to view each locus independently, there are other metrics that are more valuable. If this drive carried different transgenes with it, then having the drive at every locus is the only way to ensure that an individual possesses all of the transgenes. This can be analyzed by specifying all of the genotypes of interest at each locus, using the `genotypes` option in `genOI_mLoci_Daisy()`. This way, our data is aggregated into two groups:  

  * 1: Individuals with any of our desired genotypes at each locus  
  * other: Individuals that do not have our desired genotypes at all loci  
  
This will divide the population into individuals with an `H` allele at all loci, and individuals that do not have an `H` allele at all loci.

```{r}
# H at every locus
aggKey <- read.csv(file = file.path(aggDir[5], "0_AggKey.csv"), header = TRUE)
aggKey

plotmPlexSingle(directory = aggDir[5], whichPatches = NULL, nonZeroGen = FALSE)
```

Looking at the analysis, we see that there is only a very small window when part of the population has an `H` allele at all loci. We can also see the population drop early on, from when the `HH` genotype was prevalent at the first locus. It is probably the fitness cost from the first locus that prevents the population from containing `H` alleles at all loci.  

Alternatively, the point of multiplexing is that the loci can act as redundancies. In this method, we would put the same transgene at each locus, and then hope that individuals contain an `H` allele at any locus. This might be useful if the population is slightly heterogeneous at each locus, and thus our transgene can't spread to completion at any single locus. By having multiple loci, it's highly likely that an individual will contain the transgene at any one locus, even if not at all of them. Our simulation matches this scenario, as there is a high fitness cost on the first locus, driving the `H` allele out of the population there, and the drive isn't as effective at loci two and three, meaning that it won't spread to completion at either of those loci alone.

```{r}
# H at any locus
aggKey <- read.csv(file = file.path(aggDir[6], "0_AggKey.csv"), header = TRUE)
aggKey

plotmPlexSingle(directory = aggDir[6], whichPatches = NULL, nonZeroGen = FALSE)
```

However, by targeting three loci with variable abilities and costs, we successfully drive our transgene into the population at nearly a 100% rate. Notice, even at the end there are still some individuals that do not contain the transgene at any locus. The resistant alleles created won't die out, because there is no cost on them in our simulation, but the population is continually mixing and the loci recombine at each generation, hence why the "failed" individuals appear and disappear. This would be reduced with some cost on the `R` allele, or if the first locus had a smaller cost (remember the `H` allele effectively disappears at that locus, so we really only have 2 effective loci here), or if the drives at the second and third loci were more effective. 


```{r, echo=FALSE}
####################
# Cleanup before next run
####################
unlink(x = outFolder, recursive = TRUE)
rm(list=ls())
```

